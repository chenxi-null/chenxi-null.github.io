<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一文理清 Java 日志框架</title>
    <link href="/2022/07/03/Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2022/07/03/Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于 java 日志框架体系相信大家都不陌生，哪怕是初入职场的年轻人也能脱口而出 slf4j + logback 或者 slf4j + log4j2 这样的日志组合，slf4j 作为日志门面不提供具体的日志实现，具体实现委托给具体的日志框架完成，接口和实现分离，日志实现的切换对上层调用方透明。方案看似很完美，但现实很骨感：由于历史原因，一些三方框架可能会使用特定的日志实现，比如 curator 就直接使用的 log4j；还有一些框架会使用另一款日志门面 common-logging，比如 spring。为了统一项目里的所有日志实现，slf4j 也提供了它的解决方案 —— “日志桥接器”，通过编译期静态绑定的方式将其他框架的日志 API 调用转发到 slf4j 上来，最终实现大一统。</p><p>结局很完美，但过程可能会比较艰辛，在实践过程中我们需要逐一分析项目的日志依赖包，引入正确的日志绑定器、桥接器，排除特定的日志包，由于日志框架的纷繁复杂，在新建项目或者自己引入三方框架的过程中，很容易出现日志配置错误的问题，比如自己之前就遇到过由于配置不当导致 spring 日志无法输出的情况，虽然 spring-boot-starter-logging 的出现部分缓解了这个问题，但在最近一次开发中，还是遇到了 spring-boot 项目引入 dubbo 后无法打印 dubbo 日志的问题。</p><p>就算之前成功配置过一次，理清了各个日志包之间的关系，但过一段时间之后也很可能因为记忆模糊，再次被各种日志包名绕进去，比如记不清 “slf4j-log4j12” 和 “log4j-over-slf4j” 哪个是绑定器哪个是桥接器，”log4j-over-slf4j” 和 “log4j-to-slf4j” 又是什么区别，这里面太多弯弯绕。<br>这篇文章的初衷就是一次捋清上述问题，作为日志框架配置的备忘录。</p><h2 id="slf4j-日志过程"><a href="#slf4j-日志过程" class="headerlink" title="slf4j 日志过程"></a>slf4j 日志过程</h2><p>本文的目的是梳理 slf4j 日志实践的全过程，为日志配置实践提供参考，所以不会涉及对日志框架原理的详细描述。</p><p>下面以这个具体case为例，简单回顾下 slf4j 日志打印的全过程：</p><ol><li>使用特定的 slf4j 桥接器，将 common-logging 日志调用转成 slf4j 的调用</li><li>使用绑定器，将 slf4j 的日志调用委托给 log4j，由 log4j 框架实现实际的日志输出</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">Component<br>|<br>| <span class="hljs-built_in">log</span> to Apache Commons Logging<br>V<br>jcl-over-slf4j.jar --- (redirect) ---&gt; SLF4j ---&gt; slf4j-log4j12-version.jar ---&gt; log4j.jar ---&gt; 输出日志<br>   桥接器                                               绑定器<br></code></pre></td></tr></table></figure><p>下面开始罗列 slf4j 具体的绑定器和桥接器，以及他们之间的区别。（图片来自 <a href="https://www.slf4j.org/legacy.html">官网</a>）</p><h3 id="slf4j-绑定器：接口绑定多种实现"><a href="#slf4j-绑定器：接口绑定多种实现" class="headerlink" title="slf4j 绑定器：接口绑定多种实现"></a>slf4j 绑定器：接口绑定多种实现</h3><img src="https://www.slf4j.org/images/concrete-bindings.png" width="500"/><p><a href="https://blog.csdn.net/yycdaizi/article/details/8276265">common-logging &amp; slf4j</a> 同属于日志接口，具体实现委派给具体的日志实现包，和 common logging 不同的是，slf4j 使用编译期绑定的方式来确定绑定器，所谓编译期绑定就是所有的slf4j绑定器实现类都使用相同的全限定类名（<code>StaticLoggerBinder</code>），引入不同的slf4j绑定器jar包，但每一个的绑定器类名都是相同的，以此来实现动态替换的目的。</p><p>slf4j 在初始化阶段如果检测到类路径中同时存在多个绑定器会直接报错。<br>e.g.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">SLF4J: Class path contains multiple SLF4J bindings.<br>SLF4J: Found binding in [jar:file:/Users/chenxi20/.m2/repository/org/slf4j/slf4j-log4j12/<span class="hljs-number">1.7</span><span class="hljs-number">.25</span>/slf4j-log4j12-<span class="hljs-number">1.7</span><span class="hljs-number">.25</span>.jar!/org/slf4j/impl/StaticLoggerBinder.class]<br>SLF4J: Found binding in [jar:file:/Users/chenxi20/.m2/repository/ch/qos/logback/logback-classic/<span class="hljs-number">1.2</span><span class="hljs-number">.3</span>/logback-classic-<span class="hljs-number">1.2</span><span class="hljs-number">.3</span>.jar!/org/slf4j/impl/StaticLoggerBinder.class]<br>SLF4J: See http:<span class="hljs-comment">//www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br>SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing <span class="hljs-title function_">implementation</span> <span class="hljs-params">(class org.slf4j.impl.Log4jLoggerFactory loaded from file:/Users/chenxi20/.m2/repository/org/slf4j/slf4j-log4j12/<span class="hljs-number">1.7</span><span class="hljs-number">.25</span>/slf4j-log4j12-<span class="hljs-number">1.7</span><span class="hljs-number">.25</span>.jar)</span>. If you are using WebLogic you will need to add <span class="hljs-string">&#x27;org.slf4j&#x27;</span> to prefer-application-packages in WEB-INF/weblogic.xml: org.slf4j.impl.Log4jLoggerFactory<br></code></pre></td></tr></table></figure><h4 id="slf4j绑定包："><a href="#slf4j绑定包：" class="headerlink" title="slf4j绑定包："></a>slf4j绑定包：</h4><table><thead><tr><th>groupId</th><th>artifactId</th><th>描述</th></tr></thead><tbody><tr><td>org.slf4j</td><td>slf4j-log4j12</td><td>Log4j</td></tr><tr><td>org.apache.logging.log4j</td><td>log4j-slf4j-impl</td><td>Log4j2</td></tr><tr><td>org.slf4j</td><td>slf4j-jcl</td><td>Commons Logging</td></tr><tr><td>org.slf4j</td><td>slf4j-jdk14</td><td>JDK 自带的日志框架</td></tr><tr><td>ch.qos.logback</td><td>logback-classic</td><td>Logback自带slf4j绑定包</td></tr></tbody></table><p>e.g. 以 slf4j + log4j2 的组合为例，maven依赖配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j2核心包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 绑定器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- slf4j核心包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="slf4j-桥接器：应用代码中使用别的日志接口，转成slf4j的方法"><a href="#slf4j-桥接器：应用代码中使用别的日志接口，转成slf4j的方法" class="headerlink" title="slf4j 桥接器：应用代码中使用别的日志接口，转成slf4j的方法"></a>slf4j 桥接器：应用代码中使用别的日志接口，转成slf4j的方法</h3><img src="https://www.slf4j.org/images/legacy.png" width="500"/><h4 id="slf4j-桥接包："><a href="#slf4j-桥接包：" class="headerlink" title="slf4j 桥接包："></a>slf4j 桥接包：</h4><table><thead><tr><th>groupId</th><th>artifactId</th><th>描述</th></tr></thead><tbody><tr><td>org.slf4j</td><td>log4j-over-slf4j</td><td>Log4j</td></tr><tr><td>org.apache.logging.log4j</td><td>log4j-to-slf4j</td><td>Log4j2</td></tr><tr><td>org.slf4j</td><td>jcl-over-slf4j</td><td>Commons Logging</td></tr><tr><td>org.slf4j</td><td>jul-to-slf4j</td><td>JDK 自带的日志框架</td></tr></tbody></table><p>P.S.<br><strong>log4j-over-slf4j</strong> vs <strong>log4j-to-slf4j</strong> :</p><img src="/images/20-57-05.png" width="500"/><p>详见：<a href="https://stackoverflow.com/questions/60972865/difference-between-log4j-to-slf4j-and-log4j-over-slf4j">difference-between-log4j-to-slf4j-and-log4j-over-slf4j</a></p><br><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="spring-boot-应用"><a href="#spring-boot-应用" class="headerlink" title="spring-boot 应用"></a>spring-boot 应用</h3><p>spring-boot-starter-logging</p><p>spring-jcl 类似 jcl-over-slf4j 桥接器，接管应用代码对 jcl 的调用，不同之处在于会通过自动检测类路径jar包的方式选择使用 log4j2，还是 slf4j，如果前两者都不存在，兜底使用 jul。</p><p>注意，spring-boot-starter-logging 只引入了 jul-to-slf4j 和 log4j-to-slf4j (log4j2 桥接器) 两种依赖，没有提供 log4j-over-slf4j (log4j1 桥接器)，加上其自带的 spring-jcl，这个 starter 对 jcl、jul、log4j2 三种日志框架都自动做了“桥接”处理，再加上默认引入的 logback 依赖，使得用户可以面对 slf4j API 编程，且默认日志框架实现为 logback。<br>因为该 starter 并没有对 log4j1 对桥接处理，如果应用里存在 log4j1 的使用，比如 curator， 就需要我们手动引入 slf4j 桥接包 log4j-over-slf4j，并且排除 log4j 依赖。</p><p>如果需要使用其他日志实现，如 log4j2，就需要将上述starter替换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>类似 spring-jcl 这种带自动检测功能的日志门面还有 org.apache.dubbo.common.logger.LoggerFactory</p><br><h2 id="拓展讨论"><a href="#拓展讨论" class="headerlink" title="拓展讨论"></a>拓展讨论</h2><ul><li>log4j vs log4j2<ol><li><p><code>log4j:log4j</code></p><pre><code class="hljs">log4j 1 仅有一个 jar 包</code></pre></li><li><p><code>log4j-api</code> + <code>log4j-core</code></p><pre><code class="hljs">  而 log4j 2 需要引入两个 jar 包。设计上分离了接口和实现</code></pre></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写给 Java 开发者看的 Spock 快速入门</title>
    <link href="/2021/04/14/Spock%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/14/Spock%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="写给-Java-开发者看的-Spock-快速入门"><a href="#写给-Java-开发者看的-Spock-快速入门" class="headerlink" title="写给 Java 开发者看的 Spock 快速入门"></a>写给 Java 开发者看的 Spock 快速入门</h1><h2 id="Spock-是什么？"><a href="#Spock-是什么？" class="headerlink" title="Spock 是什么？"></a>Spock 是什么？</h2><p>看下它的 <a href="https://github.com/spockframework/spock">github</a> 描述:</p><blockquote><p>The Enterprise-ready testing and specification framework.</p></blockquote><p><a href="http://spockframework.org/">官网介绍</a>:</p><blockquote><p>Spock is a testing and specification framework for Java and Groovy applications.</p><p>What makes it stand out from the crowd is its beautiful and highly expressive specification language.</p><p>Thanks to its JUnit runner, Spock is compatible with most IDEs, build tools, and continuous integration servers.</p><p>Spock is inspired from JUnit, RSpec, jMock, Mockito, Groovy, Scala, Vulcans, and other fascinating life forms.</p></blockquote><p>官方文档：<a href="http://spockframework.org/spock/docs/1.2/all_in_one.html">Spock Framework Reference Documentation</a><br><br></p><p>简而言之，Spock 是一款测试框架，支持 Java 或者 Groovy 应用，是采用 groovy 语言写的，得益于 groovy 的语言特性，Spock 相比较 JUnit 语法更简练、提供更强大的功能。</p><br><h2 id="和其他-Java-测试框架的对比"><a href="#和其他-Java-测试框架的对比" class="headerlink" title="和其他 Java 测试框架的对比"></a>和其他 Java 测试框架的对比</h2><p>对比其他的 Java 测试框架，包括常见的 JUnit, testNG, 一些 Java BDD 框架, 例如 Cucumber(Gherkin)，<a href="https://jbehave.org/">JBehave</a>, Spock 有如下优势:</p><ul><li><p>基于它提供的一套 DSL，能更好地实践 BDD —— 测试用例即需求说明书。 (<code>given-when-then</code>)</p></li><li><p>写更少的测试代码，测试用例可读性更强，一些 awesome feature，后面会详细解释:</p><ul><li>blocks, (no)thrown, ‘&#x3D;&#x3D;’,</li><li>where, table, database,</li><li>with, verifyAll</li><li>更灵活的 Mock&#x2F;Stub 语法</li></ul></li><li><p>兼容 <code>JUnit</code>, 支持 JUnit 里的所有 <code>@Rule</code>，可以平滑地从 JUnit 迁移到 Spock</p></li></ul><h3 id="Spock-vs-JUnit"><a href="#Spock-vs-JUnit" class="headerlink" title="Spock vs JUnit"></a>Spock vs JUnit</h3><p>通过一个参数化测试的例子直观感受下：</p><p>Spock:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> spock.lang.Specification<br><span class="hljs-keyword">import</span> spock.lang.Unroll<br><br><span class="hljs-meta">@Title</span>(<span class="hljs-string">&quot;Testing file extension validation method&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageValidatorShould</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Specification</span> &#123;<br>  <br>   <span class="hljs-meta">@Unroll</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-string">&quot;validate extension of #fileToValidate&quot;</span>() &#123;<br>       <span class="hljs-symbol">when:</span> <span class="hljs-string">&quot;validator checks filename&quot;</span><br>       <span class="hljs-keyword">def</span> isValid = validate fileToValidate<br><br>       <span class="hljs-symbol">then:</span> <span class="hljs-string">&quot;return appropriate result&quot;</span><br>       isValid == expectedResult<br><br>       <span class="hljs-symbol">where:</span> <span class="hljs-string">&quot;input files are&quot;</span><br>       fileToValidate || expectedResult<br>       <span class="hljs-string">&#x27;some.jpeg&#x27;</span>    || <span class="hljs-literal">true</span><br>       <span class="hljs-string">&#x27;some.jpg&#x27;</span>     || <span class="hljs-literal">true</span><br>       <span class="hljs-string">&#x27;some.tiff&#x27;</span>    || <span class="hljs-literal">false</span><br>       <span class="hljs-string">&#x27;some.bmp&#x27;</span>     || <span class="hljs-literal">true</span><br>       <span class="hljs-string">&#x27;some.png&#x27;</span>     || <span class="hljs-literal">false</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JUnit:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.junit.runners.Parameterized;<br><span class="hljs-keyword">import</span> org.junit.runners.Parameterized.Parameters;<br><br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Arrays.asList;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.assertEquals;<br><br><span class="hljs-meta">@RunWith(Parameterized.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageValidator</span> &#123;<br><br>   <span class="hljs-meta">@Parameters</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collection&lt;Object[]&gt; data() &#123;<br>       <span class="hljs-keyword">return</span> asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[][]&#123;<br>               &#123;<span class="hljs-string">&quot;some.jpeg&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>               &#123;<span class="hljs-string">&quot;some.jpg&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>               &#123;<span class="hljs-string">&quot;some.tiff&quot;</span>, <span class="hljs-literal">false</span>&#125;,<br>               &#123;<span class="hljs-string">&quot;some.bmp&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>               &#123;<span class="hljs-string">&quot;some.png&quot;</span>, <span class="hljs-literal">false</span>&#125;<br>       &#125;);<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> String file;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isValid;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ImageValidator</span><span class="hljs-params">(String input, <span class="hljs-type">boolean</span> expected)</span> &#123;<br>       file = input;<br>       isValid = expected;<br>   &#125;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateFileExtension</span><span class="hljs-params">()</span> &#123;<br>       assertEquals(isValid, validate(file));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述例子摘自：<a href="https://www.blazemeter.com/blog/spock-vs-junit-which-one-should-you-choose">link</a></p><hr><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="测试方法的生命周期"><a href="#测试方法的生命周期" class="headerlink" title="测试方法的生命周期"></a>测试方法的生命周期</h3><p>和 JUnit 基本类似，详见：<a href="http://spockframework.org/spock/docs/1.2/all_in_one.html#_comparison_to_junit">对比 JUnit</a></p><p><img src="http://spockframework.org/spock/docs/1.2/images/Blocks2Phases.png" alt="Blocks"></p><p>e.g.:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;events are published to all subscribers&quot;</span>() &#123;<br>  <span class="hljs-symbol">given:</span> <span class="hljs-string">&quot;准备数据&quot;</span><br>  <span class="hljs-keyword">def</span> subscriber1 = Mock(Subscriber)<br>  <span class="hljs-keyword">def</span> subscriber2 = Mock(Subscriber)<br>  <span class="hljs-keyword">def</span> publisher = <span class="hljs-keyword">new</span> Publisher()<br>  publisher.add(subscriber1)<br>  publisher.add(subscriber2)<br><br>  <span class="hljs-symbol">when:</span> <span class="hljs-string">&quot;触发被测试对象的一个行为&quot;</span><br>  publisher.fire(<span class="hljs-string">&quot;event&quot;</span>)<br><br>  <span class="hljs-symbol">then:</span> <span class="hljs-string">&quot;验证该行为的结果是否符合预期&quot;</span><br>  <span class="hljs-comment">// 验证 subscriber1 的 receive 方法是否被调用一次，且入参为 &quot;event&quot;</span><br>  <span class="hljs-number">1</span> * subscriber1.receive(<span class="hljs-string">&quot;event&quot;</span>)<br>  <span class="hljs-number">1</span> * subscriber2.receive(<span class="hljs-string">&quot;event&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简洁的-Mock-语法"><a href="#简洁的-Mock-语法" class="headerlink" title="简洁的 Mock 语法"></a>简洁的 Mock 语法</h3><p>Spock 有自带的一套 Mock 框架，提供非常简洁直观的语法，从上面那个例子也能看出它的可读性很强，如果同样的代码用 Java Mock 框架，如 Mockito，来写的话，是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Mockito.verify(subscriber1, Mockito.times(<span class="hljs-number">1</span>)).sendMail(<span class="hljs-string">&quot;event&quot;</span>);<br>Mockito.verify(subscriber2, Mockito.times(<span class="hljs-number">1</span>)).sendMail(<span class="hljs-string">&quot;event&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="隐式断言"><a href="#隐式断言" class="headerlink" title="隐式断言"></a>隐式断言</h3><blockquote><p>Within the <code>then</code> and <code>expect</code> blocks, assertions are implicit</p></blockquote><p>无需显示写 assert，语法简洁</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">when:</span><br><span class="hljs-comment">//...</span><br><br><span class="hljs-attr">then:</span><br><span class="hljs-comment">// `then` 代码块里面直接写条件判断语句，无需显式调用 assert 方法</span><br><span class="hljs-comment">// 等价于: Assert.assertTrue(mailBox.containsMail(msg))</span><br>mailBox.containsMail(msg)<br><br><span class="hljs-comment">// 等价于: Assert.assertEquals(name, &#x27;value&#x27;)</span><br>name == <span class="hljs-string">&#x27;value&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h3><p><code>thrown, notThrown</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">when:</span><br>stack.pop()<br><br><span class="hljs-attr">then:</span><br>thrown(EmptyStackException)<br>stack.empty<br></code></pre></td></tr></table></figure><h3 id="各种-Groovy-的语法糖"><a href="#各种-Groovy-的语法糖" class="headerlink" title="各种 Groovy 的语法糖"></a>各种 Groovy 的语法糖</h3><p>Groovy 提供的很多语法糖帮助开发不需要写很多模板代码，使用 Spock 写的测试用例更简洁易读，得益于它提供的这套 DSL，整个测试用例的结构更清晰、看起来更接近自然语言。</p><p>e.g:</p><blockquote><p>Java’s &#x3D;&#x3D; is actually Groovy’s is() method, and Groovy’s &#x3D;&#x3D; is a clever equals()!</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">str == <span class="hljs-string">&quot;content&quot;</span>     <span class="hljs-comment">// assert the equality between strings</span><br>list == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-comment">// assert the equality between lists</span><br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">publisher.subscribers &lt;&lt; subscriber <span class="hljs-comment">// &lt;&lt; is a Groovy shorthand for List.add()</span><br>publisher.subscribers - subscriber <span class="hljs-comment">// to remove element from List</span><br></code></pre></td></tr></table></figure><p>参考:<br><a href="http://groovy-lang.org/syntax.html">groovy-lang.org&#x2F;syntax.html</a><br><a href="https://learnxinyminutes.com/docs/groovy/">更多例子</a></p><h3 id="支持-Java-的各种测试框架"><a href="#支持-Java-的各种测试框架" class="headerlink" title="支持 Java 的各种测试框架"></a>支持 Java 的各种测试框架</h3><p>包括 JUnit, Mockito, JAssert, Hamcrest, 等等</p><h3 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h3><p>杀手级特性</p><h4 id="Data-Tables"><a href="#Data-Tables" class="headerlink" title="Data Tables"></a>Data Tables</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Specification</span> &#123;<br>  <span class="hljs-keyword">def</span> <span class="hljs-string">&quot;maximum of two numbers&quot;</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) &#123;<br>    <span class="hljs-symbol">expect:</span><br>    Math.max(a, b) == c<br><br>    <span class="hljs-symbol">where:</span><br>    a | b | c<br>    <span class="hljs-number">1</span> | <span class="hljs-number">3</span> | <span class="hljs-number">3</span><br>    <span class="hljs-number">7</span> | <span class="hljs-number">4</span> | <span class="hljs-number">7</span><br>    <span class="hljs-number">0</span> | <span class="hljs-number">0</span> | <span class="hljs-number">0</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Data-Pipes"><a href="#Data-Pipes" class="headerlink" title="Data Pipes"></a>Data Pipes</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">...<br><span class="hljs-attr">where:</span><br>a &lt;&lt; [<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>]<br>b &lt;&lt; [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>c &lt;&lt; [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h3 id="报告生成"><a href="#报告生成" class="headerlink" title="报告生成"></a>报告生成</h3><p><code>given</code> <code>when</code> <code>then</code> 等代码块里的描述是可以导出到文档中的：</p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8325479993/2df3/bece/ef4c/83442768d591857df3dc6bbd33a75d2e.png" width="500"/><p>测试用例是给开发人员看的文档，BDD 风格的测试用例可读性更强，帮忙阅读者更快地熟悉复杂的业务逻辑。</p><hr><h2 id="从-Java-迁移到-Groovy-的注意事项"><a href="#从-Java-迁移到-Groovy-的注意事项" class="headerlink" title="从 Java 迁移到 Groovy 的注意事项"></a>从 Java 迁移到 Groovy 的注意事项</h2><h3 id="java-lambda-expression-vs-groovy-closure"><a href="#java-lambda-expression-vs-groovy-closure" class="headerlink" title="java lambda expression vs groovy closure"></a>java lambda expression vs groovy closure</h3><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">() <br>e.g: Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(i -&gt; i * <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>groovy:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">&#123;&#125;<br>e.<span class="hljs-attr">g:</span> Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map &#123; i -&gt; i * <span class="hljs-number">2</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="注解当中的：-vs"><a href="#注解当中的：-vs" class="headerlink" title="注解当中的：[] vs {}"></a>注解当中的：<code>[]</code> vs<code> &#123;&#125;</code></h3><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ContextConfiguration(classes = &#123;A.class, B.class&#125;)</span><br></code></pre></td></tr></table></figure><p>groovy:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@ContextConfiguration</span>(classes = [A.<span class="hljs-keyword">class</span>, B.<span class="hljs-keyword">class</span>])<br><span class="hljs-meta">@ContextConfiguration</span>(classes = [A, B]) <span class="hljs-comment">// the &#x27;.class&#x27; suffix can also be ignored</span><br>String[] arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="groovy-更便捷的-getter-setter"><a href="#groovy-更便捷的-getter-setter" class="headerlink" title="groovy 更便捷的 getter &amp; setter"></a>groovy 更便捷的 getter &amp; setter</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><br>Person person = <span class="hljs-keyword">new</span> Person()<br>person.name = <span class="hljs-string">&#x27;tom&#x27;</span> <span class="hljs-comment">// 等价于 person.setName(&quot;tom&quot;);</span><br>person.age = <span class="hljs-number">10</span> <span class="hljs-comment">// 等价于 person.setAge(10);</span><br>println person.name <span class="hljs-comment">// 等价于 System.out.println(person.getName())</span><br>println person.age <span class="hljs-comment">// 等价于 System.out.println(person.getAge())</span><br></code></pre></td></tr></table></figure><h2 id="落地实践"><a href="#落地实践" class="headerlink" title="落地实践"></a>落地实践</h2><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8325266133/7d08/48cb/0fc4/a4d9b708ff9dd8ddb7eea5bfb2ada270.png" width="500"/><p>生产代码用 java 写，测试代码用 groovy，享受新语言优势的同时又无需承担线上风险。<br>e.g.<br><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8325587220/e46f/595f/de6c/83ff35430e1c5f2c4a6ab0838cb86cf7.png" width="500"/></p><h3 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h3><ul><li>groovy 号称是 “Java 的脚本的语言”，Java 程序员学习 groovy 的成本较低。</li><li>Spock 中文资料不是很多，直接阅读<a href="https://github.com/spockframework/spock">官方文档</a>是最推荐的学习方式</li></ul><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>如果对 groovy 语法不是太熟悉的话，可以选择在 Spock 里写 Java 代码，groovy 兼容绝大多数的 java 语法。 e.g.:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 各种 groovy 语法和 Java 语法的混用，</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>()<br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br>list &lt;&lt; <span class="hljs-string">&#x27;4&#x27;</span><br>list &lt;&lt; <span class="hljs-string">&quot;5&quot;</span><br>list.add(<span class="hljs-string">&quot;6&quot;</span>)<br>println(list[<span class="hljs-number">0</span>])<br>println list.get(<span class="hljs-number">0</span>)<br>System.out.println(list[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>groovy 还兼容 JUnit (Spock 的底层是基于 Junit 引擎实现的)和 maven (因为 maven 构建只认 class 文件)，因此也兼容 CI 平台。</p><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><ol><li><p>跨语言，有一定学习成本和推广难度</p></li><li><p>社区活跃度和 JUnit 还不是一个数量级，我之前在使用过程中也遇到过一些小问题，不过影响不大</p></li><li><p>习惯 Spock 之后容易厌弃 JUnit ……<br>分享一个之前在 spring-redis 源码里看到的彩蛋，这位老哥可能是写单测写太辛苦了，直接在代码注释里吐槽起了 JUnit，甚至还画了一个表情 (摊手)  </p> <img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8325339447/c6e0/1999/0dd8/2857d4e659391fcb1aefcff280f9b453.png" width="500"/></li></ol><h3 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h3><p>pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- spock --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.groovy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>groovy-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.spockframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spock-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2-groovy-2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.spockframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spock-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2-groovy-2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.athaydes<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spock-reports<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.gmavenplus<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmavenplus-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compileTests<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*Test.java<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*Spec.java<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TDD 实战 — 如何测试异步任务</title>
    <link href="/2020/07/21/tdd-in-action-async-assert/"/>
    <url>/2020/07/21/tdd-in-action-async-assert/</url>
    
    <content type="html"><![CDATA[<p>异步操作，包括进程内的异步操作，也包括跨系统的调用，如 MQ 的发布-订阅场景，异步任务中间件场景等，异步操作通常可以提升系统的吞吐量、降低模块耦合，但在我们平时的写单元&#x2F;集成测试的过程中，如何对这些异步操作进行测试却成了一个难题。</p><p>本文列举了几种测试异步操作的解决方案，希望为大家提供一些思路，帮助大家写出更简洁优雅的代码😄</p><p>代码中的测试用例是用 Spock 写的，不熟悉 Spock 这一测试框架的同学可以看下我之前写的这篇文章 <a href="/2019/01/28/Spock-Tutorial-for-Javaer/">Spock-Tutorial-for-Javaer</a></p><p>下面以一个邮件发送的案例作为我们的例子：<br><code>AsyncMailSender</code> 是邮件发送者，通过调用 <code>sendMail</code> 方法异步地发送邮件，相当于 MQ 场景中的 Producer 角色；<br><code>MailBox</code> 是邮件的接受者，相当于 MQ 中的 Consumer 角色。</p><p>最简单暴力的方式就是使用 sleep 了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">def <span class="hljs-string">&quot;async assert with sleep&quot;</span>() &#123;<br>    <span class="hljs-keyword">when</span>: <span class="hljs-string">&quot;invoke async operation&quot;</span><br>    asyncMailSender.sendMail(msg)<br><br>    then:<br>    sleep(<span class="hljs-number">2000</span>)<br>    and:<br>    mailBox.containsMail(msg)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的缺点就是 sleep 的时间长度难以控制，设置长了会增大测试的耗时，设置短了可能出现 consumer 还没收到消息的情况，导致测试失败</p><p>针对 sleep 的缺陷，更好的解决方案也比较容易想到，那就是使用<strong>轮询</strong>的方式，不断检查 consumer 是否接收到指定的消息，收到的话就返回 assert 成功，如果超过设置的最大等待时间还没有收到消息就返回失败。</p><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>对于这种需求，社区早就有比较成熟的工具，不需要我们再重复造轮子了</p><h3 id="Awaitility"><a href="#Awaitility" class="headerlink" title="Awaitility"></a>Awaitility</h3><p>同时支持 Java 和 Groovy，提供了丰富的 DSL 风格的 API</p><p><a href="https://github.com/awaitility/awaitility">Awaitility</a> 在 github 上的介绍:</p><blockquote><p>Awaitility is a small Java DSL for synchronizing asynchronous operations</p><p>Testing asynchronous systems is hard. Not only does it require handling threads, timeouts and concurrency issues, but the intent of the test code can be obscured by all these details. Awaitility is a DSL that allows you to express expectations of an asynchronous system in a concise and easy to read manner.</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// https://github.com/awaitility/awaitility/wiki/Groovy</span><br><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;async assert with Awaitility&quot;</span>() &#123;<br>    <span class="hljs-symbol">when:</span> <span class="hljs-string">&quot;invoke async operation&quot;</span><br>    asyncMailSender.sendMail(msg)<br><br>    <span class="hljs-symbol">then:</span><br>    await().atLeast(Duration.ofMillis(<span class="hljs-number">10</span>)).atMost(Duration.ofSeconds(<span class="hljs-number">3</span>))<br>            .until(&#123; mailBox.numOfReceivedMail() &#125;, equalTo(<span class="hljs-number">1</span>))<br>    <span class="hljs-symbol">and:</span><br>    mailBox.containsMail(msg)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="PollingCondition-of-Spock"><a href="#PollingCondition-of-Spock" class="headerlink" title="PollingCondition of Spock"></a>PollingCondition of Spock</h3><p>PollingCondition 是 Spock 自带的，个人认为它的语法比 Awaitility 更简洁</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;async assert with PollingCondition&quot;</span>() &#123;<br>    PollingConditions pollingConditions = <span class="hljs-keyword">new</span> PollingConditions()<br><br>    <span class="hljs-symbol">when:</span><br>    asyncMailSender.sendMail(msg)<br><br>    <span class="hljs-symbol">then:</span><br>    pollingConditions.within(<span class="hljs-number">2</span>, &#123; mailBox.containsMail(msg) &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="主动通知"><a href="#主动通知" class="headerlink" title="主动通知"></a>主动通知</h2><p>除了轮询 consumer、不断检查 consumer 状态这种方案，还可以基于 wait-notify 的模型，让 consumer 在满足条件后主动通知 “断言者”</p><h3 id="在-Receiver-处添加-Hook-Callback"><a href="#在-Receiver-处添加-Hook-Callback" class="headerlink" title="在 Receiver 处添加 Hook&#x2F;Callback"></a>在 Receiver 处添加 Hook&#x2F;Callback</h3><p>对代码有一定侵入性，如何这里 Hook 只是为测试服务的话</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;async assert by modifying feat code, for example, adding hook&quot;</span>() &#123;<br>    <span class="hljs-symbol">given:</span><br>    <span class="hljs-keyword">def</span> f = <span class="hljs-keyword">new</span> CompletableFuture()<br>    Mailbox mailbox = <span class="hljs-keyword">new</span> Mailbox()<br>    mailbox.setReceivedHook &#123; msg -&gt; f.complete(msg) &#125;<br>    AsyncMailSender asyncMailSender = <span class="hljs-keyword">new</span> AsyncMailSender(mailbox)<br><br>    <span class="hljs-symbol">when:</span><br>    asyncMailSender.sendMail(msg)<br><br>    <span class="hljs-symbol">then:</span><br>    msg == f.get()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Mock-Receiver"><a href="#Mock-Receiver" class="headerlink" title="Mock Receiver"></a>Mock Receiver</h3><p>还有一种思路，如果不关心 receiver 的内部逻辑，只关心 receiver 的 receive 方法 (例子里是 <code>MailBox.receiveMail</code>) 是否被调用过的话，可以考虑直接对 receiver 进行 mock，在 mock 逻辑里添加 notify 的代码，然后在 assert 处等待，这里的 wait-and-notify 流程和上面的例子是一致的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;async assert by mocking receiver&quot;</span>() &#123;<br>    <span class="hljs-symbol">given:</span><br>    <span class="hljs-keyword">def</span> f = <span class="hljs-keyword">new</span> CompletableFuture()<br>    Mailbox mailbox = Stub &#123;<br>        receiveMail(_) &gt;&gt; &#123; String _msg -&gt; f.complete(msg) &#125;<br>    &#125;<br>    AsyncMailSender asyncMailSender = <span class="hljs-keyword">new</span> AsyncMailSender(mailbox)<br><br>    <span class="hljs-symbol">when:</span><br>    asyncMailSender.sendMail(msg)<br><br>    <span class="hljs-symbol">then:</span><br>    msg == f.get()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AsyncCondition-of-Spock"><a href="#AsyncCondition-of-Spock" class="headerlink" title="AsyncCondition of Spock"></a>AsyncCondition of Spock</h3><p>上面的两个例子是通过 JDK 的 <code>CompletableFuture</code> 实现 wait-and-notify 的，当然也可以使用其他的 JDK API，比如 <code>CountDownLatch</code> 等，这里推荐一个 Spock 内置的工具 —— AsyncCondition:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;async assert with `AsyncCondition`&quot;</span>() &#123;<br>    <span class="hljs-symbol">given:</span><br>    <span class="hljs-keyword">def</span> asyncConditions = <span class="hljs-keyword">new</span> AsyncConditions()<br>    Mailbox mailbox = Stub &#123;<br>        receiveMail(_) &gt;&gt; &#123; String _msg -&gt; asyncConditions.evaluate &#123; <span class="hljs-keyword">assert</span> _msg == msg &#125; &#125;<br>    &#125;<br>    AsyncMailSender asyncMailSender = <span class="hljs-keyword">new</span> AsyncMailSender(mailbox)<br><br>    <span class="hljs-symbol">when:</span><br>    asyncMailSender.sendMail(msg)<br><br>    <span class="hljs-symbol">then:</span><br>    asyncConditions.await(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>AsyncCondition 的使用方法和 <code>CompletableFuture</code> 以及 <code>CountDownLatch</code> 是差不多的，但好处是可以利用 Spock 在 assert 失败时会打印详细的失败信息这一特性，在 assert 复杂对象出现失败时，方便排查，e.g:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;AsyncConditions can report detailed failed result of assertion&quot;</span>() &#123;<br>    <span class="hljs-keyword">def</span> asyncConditions = <span class="hljs-keyword">new</span> AsyncConditions()<br>    <span class="hljs-symbol">when:</span><br>    <span class="hljs-keyword">def</span> msg = <span class="hljs-keyword">new</span> Message(<span class="hljs-attr">id:</span> <span class="hljs-number">100</span>, <span class="hljs-attr">content:</span> <span class="hljs-string">&#x27;content1&#x27;</span>, <span class="hljs-attr">tag:</span> <span class="hljs-string">&#x27;tag1&#x27;</span>);<br>    Thread.start &#123;<br>        asyncConditions.evaluate &#123;<br>            verifyAll(msg) &#123;<br>                id == <span class="hljs-number">101</span><br>                content == <span class="hljs-string">&#x27;content2&#x27;</span><br>                tag == <span class="hljs-string">&#x27;tag1&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-symbol">then:</span><br>    asyncConditions.await(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/2020-07-29-11-43-33.png"></p><h3 id="字节码生成工具"><a href="#字节码生成工具" class="headerlink" title="字节码生成工具"></a>字节码生成工具</h3><p>我在网上还看到过使用字节码生成工具来测试异步操作的“奇技淫巧”，有兴趣的朋友可以看下这篇文章：<br><a href="https://dzone.com/articles/testing-asynchronous-operations-in-spring-with-spo">Testing Asynchronous Operations in Spring With Spock and Byteman - DZone Performance</a></p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>上面介绍的几种方法都是比较通用的，不管是针对进程内还是跨进程的异步场景都是适用的，但如果我们要测试的仅仅是进程内部的异步通信场景，其实可以尝试如下方式:<br>如果 Producer 是通过线程池的方式异步调用 Consumer 的 receive 方法，我们可以等待 Producer 的线程池执行结束后，再去 assert Consumer</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;async assert with JDK Thread APIs&quot;</span>() &#123;<br>    <span class="hljs-symbol">when:</span><br>    asyncMailSender.sendMail(msg)<br><br>    <span class="hljs-symbol">and:</span> <span class="hljs-string">&quot;wait that all tasks have completed execution in thread pool&quot;</span><br>    ExecutorService executorService = asyncMailSender.getExecutorService()<br>    executorService.shutdown()<br>    executorService.awaitTermination(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<br>    log.debug(executorService.toString())<br><br>    <span class="hljs-symbol">then:</span><br>    mailBox.containsMail(msg)<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>以上这些测试用例的完整代码可以通过我的 <a href="https://github.com/chenxi-null/tdd/blob/master/async-assertion/src/test/groovy/com/chenxi/tdd/async/AsyncMailSenderTest.groovy">github 仓库</a> 获取</p>]]></content>
    
    
    <categories>
      
      <category>TDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Seata 分布式事务框架 源码解析 — 优雅停机</title>
    <link href="/2020/06/05/seata-src-code-graceful-shutdown/"/>
    <url>/2020/06/05/seata-src-code-graceful-shutdown/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Seata 是什么？</p><blockquote><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p></blockquote><p>Github 地址: <a href="https://github.com/seata/seata">https://github.com/seata/seata</a></p><p>文章概述：</p><ul><li><p>基于源码分析了 Seata 优雅停机的实现方式</p></li><li><p>同时分析了 Spring 的优雅停机, 介绍了 Spring Context 的生命周期管理，顺带提及了它对于提高软件可测试性的意义</p></li><li><p>对比了 Dubbo 的优雅停机策略</p></li></ul><p>Seata 的优雅停机模块其实并没有涉及太多 Seata 本身的领域概念，本文更多的还是以 Seata 为引子，介绍了优雅停机在框架设计中的优秀实践，不熟悉 Seata 的同学也可以放心食用～</p><hr><p>下面是正文部分：</p><p>Seata 优雅停机的逻辑主要是放在 <code>io.seata.core.rpc.netty.ShutdownHook</code> 这个类。</p><p>我们先看 <code>io.seata.server.Server</code> 里是如何使用 <code>ShutdownHook</code> 的:</p><p>在 <code>Server</code> 的 main 方法里调用 <code>ShutdownHook</code> 的 addDisposable 方法，注册 disposable 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// register ShutdownHook</span><br>ShutdownHook.getInstance().addDisposable(coordinator);<br>ShutdownHook.getInstance().addDisposable(rpcServer);<br></code></pre></td></tr></table></figure><h3 id="JVM-层面的优雅停机"><a href="#JVM-层面的优雅停机" class="headerlink" title="JVM 层面的优雅停机"></a>JVM 层面的优雅停机</h3><p><code>ShutdownHook</code> 在类加载时会注册了一个 JVM shutdown hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    Runtime.getRuntime().addShutdownHook(SHUTDOWN_HOOK);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ShutdownHook</code> 继承自 <code>Thread</code>，JVM 在正常关闭时执行 Thread#run 方法里面的逻辑，依次执行之前添加的所有 disposable 的对象的 destory 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    destroyAll();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyAll</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (LOGGER.isDebugEnabled()) &#123;<br>        LOGGER.debug(<span class="hljs-string">&quot;destroyAll starting&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!destroyed.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>) &amp;&amp; CollectionUtils.isEmpty(disposables)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Disposable disposable : disposables) &#123;<br>        disposable.destroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Spring-层面的优雅停机"><a href="#Spring-层面的优雅停机" class="headerlink" title="Spring 层面的优雅停机"></a>Spring 层面的优雅停机</h3><p>以上是 Seata <code>Server</code> 使用 <code>ShutdownHook</code> 的方式，<code>ShutdownHook</code> 还会被 Seata Client 端使用，具体是被 <code>DefaultSagaTransactionalTemplate</code> <code>GlobalTransactionScanner</code> 这两个类使用，我们看下在 <code>GlobalTransactionScanner</code> 里的具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GlobalTransactionScanner 实现了 Spring 的 DisposableBean 接口</span><br><span class="hljs-comment">// Spring Context 在关闭时会回调这些 DisposableBean 的 destory 方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    ShutdownHook.getInstance().destroyAll();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initClient</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//init TM</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//init RM</span><br>    <span class="hljs-comment">//...</span><br>    registerSpringShutdownHook();<br>&#125;<br><br><span class="hljs-comment">// 在初始化时，向 Seata ShutdownHook 注册 Disposable 对象，</span><br><span class="hljs-comment">// 这些的 Disposable 是 Seata 自定义的，注意和 Spring 的 DisposableBean 区分</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerSpringShutdownHook</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (applicationContext <span class="hljs-keyword">instanceof</span> ConfigurableApplicationContext) &#123;<br>        ((ConfigurableApplicationContext) applicationContext).registerShutdownHook(); <span class="hljs-comment">// [1]</span><br>        ShutdownHook.removeRuntimeShutdownHook(); <span class="hljs-comment">// [2]</span><br>    &#125;<br>    ShutdownHook.getInstance().addDisposable(TmRpcClient.getInstance(applicationId, txServiceGroup));<br>    ShutdownHook.getInstance().addDisposable(RmRpcClient.getInstance(applicationId, txServiceGroup));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里有两个有意思的地方，分别是代码里标注[1]和[2]，下面我们来逐一分析：</p><h3 id="ConfigurableApplicationContext-registerShutdownHook"><a href="#ConfigurableApplicationContext-registerShutdownHook" class="headerlink" title="ConfigurableApplicationContext#registerShutdownHook"></a><code>ConfigurableApplicationContext#registerShutdownHook</code></h3><p>这是 Spring <code>AbstractApplicationContext</code> 里的实现逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Register a shutdown hook with the JVM runtime, closing this context</span><br><span class="hljs-comment"> * on JVM shutdown unless it has already been closed at that time.</span><br><span class="hljs-comment"> * &lt;p&gt;Delegates to &#123;<span class="hljs-doctag">@code</span> doClose()&#125; for the actual closing procedure.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Runtime#addShutdownHook</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #close()</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #doClose()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerShutdownHook</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.shutdownHook == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// No shutdown hook registered yet.</span><br><span class="hljs-built_in">this</span>.shutdownHook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (startupShutdownMonitor) &#123;<br>doClose();<br>&#125;<br>&#125;<br>&#125;;<br>Runtime.getRuntime().addShutdownHook(<span class="hljs-built_in">this</span>.shutdownHook);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>doClose</code> 方法就是 Spring Context 关闭时做的各种清理工作，包括刚才提到的回调各个 DisposableBean 的 destroy 方法。</p><p>通过这行<code>Runtime.getRuntime().addShutdownHook(this.shutdownHook);</code> 我们可以知道 ApplicationContext 的 registerShutdownHook 方法最终还是把清理工作的时机交给 JVM 的 shutdown hook </p><p>所以调用了 ApplicationContext#registerShutdownHook 之后就把原先 Seata <code>ShutdownHook</code> 注册的 JVM shutdown hook 移除掉，避免重复调用 <code>ShutdownHook#destoryAll</code>。</p><p><code>ShutdownHook#removeRuntimeShutdownHook</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * for spring context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRuntimeShutdownHook</span><span class="hljs-params">()</span> &#123;<br>    Runtime.getRuntime().removeShutdownHook(SHUTDOWN_HOOK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ConfigurableApplicationContext-close"><a href="#ConfigurableApplicationContext-close" class="headerlink" title="ConfigurableApplicationContext#close"></a><code>ConfigurableApplicationContext#close</code></h3><p>说到 <code>AbstractApplicationContext</code> 的 <code>registerShutdownHook</code> 方法，不得不提一下它的另一个 <code>close</code> 方法，<br>close 方法和 registerShutdownHook 一样，也是对 <code>doClose</code> 的委托，只是他们的调用 <code>doClose</code> 的时机不同:  </p><ul><li><code>registerShutdownHook</code> 是把调用时机交给 JVM 的 shutdown hook，在 JVM 关闭时执行</li><li><code>close</code> 是直接执行，同时把 ApplicationContext 之前注册的 JVM shutdown hook 移除掉</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Close this application context, destroying all beans in its bean factory.</span><br><span class="hljs-comment"> * &lt;p&gt;Delegates to &#123;<span class="hljs-doctag">@code</span> doClose()&#125; for the actual closing procedure.</span><br><span class="hljs-comment"> * Also removes a JVM shutdown hook, if registered, as it&#x27;s not needed anymore.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #doClose()</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #registerShutdownHook()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br>doClose();<br><span class="hljs-comment">// If we registered a JVM shutdown hook, we don&#x27;t need it anymore now:</span><br><span class="hljs-comment">// We&#x27;ve already explicitly closed the context.</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.shutdownHook != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Runtime.getRuntime().removeShutdownHook(<span class="hljs-built_in">this</span>.shutdownHook);<br>&#125;<br><span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br><span class="hljs-comment">// ignore - VM is already shutting down</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在加上 Spring 的清理逻辑之后似乎有点绕，但是不要慌，我们来整理一下:</p><p>Seata 的 <code>ShutdownHook</code> 通过 <code>addDisposable</code> 注册 disposable 对象，这里 server 端和 client 端的用法都是一样的。</p><p><code>ShutdownHook</code> 在类加载时会注册一个 JVM shutdown hook，在 JVM 正常关闭时，最终会调用 <code>ShutdownHook#distroyAll</code> 对象销毁所有先前注册过的 disposable 对象。</p><p>而 Client 端因为是放在 Spring 容器当中的，所以把 <code>ShutdownHook#distroyAll</code> 的执行时机完全交给 Spring Context 来控制。</p><p>Spring Context 的销毁时机又分为两种:</p><ul><li><p>调用 <code>registerShutdownHook</code>: 注册一个 JVM shutdown hook，在 JVM 关闭时执行</p></li><li><p>调用 <code>close</code>，直接执行清理逻辑</p></li></ul><h3 id="可测试性架构"><a href="#可测试性架构" class="headerlink" title="可测试性架构"></a>可测试性架构</h3><p><code>ConfigurableApplicationContext#close</code> 方法可以让用户灵活地控制 Spring Context 的生命周期，比如一个 JVM 应用内存在多个 ApplicationContext 或者我们需要销毁某个 ApplicationContext 的时候，可以直接调用 close 方法，而不需要等到 JVM 关闭时才能执行 context 的清理工作。</p><p>还有一个典型应用是我们在写基于 Spring Context 的集成测试的时候，在每个测试用例执行完毕后需要调用 <code>ConfigurableApplicationContext#close</code> 方法销毁 spring context：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoSpringJUnitTest</span> &#123;<br><br>    ConfigurableApplicationContext ctx;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 开始测试时创建 context</span><br>        ctx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(TestConfig.class);<br>        <span class="hljs-comment">// do some testing...</span><br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 测试结束后销毁 context</span><br>        <span class="hljs-keyword">if</span> (ctx != <span class="hljs-literal">null</span>) &#123;<br>            ctx.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里暂时先不考虑使用 Spring-Test <code>@ContextConfiguration</code> 或者 <code>@SpringBootTest</code> 的情况，使用它们的话 Spring 会默认复用 context，详细用法见 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-framework">Spring-Test 官方文档</a></p><p>如果没有正确关闭 spring context 的话，在批量地执行多个测试用例时就有可能出现在一个 JVM 当中同时存在多个相同的 spring context，可能存在多个类型相同的后台任务，如异步任务调度、MQ Consumer，多个线程竞争同一资源，导致测试用例出现概率性失败。</p><p>所以，把框架里的清理工作交给 Spring 来管理是非常明智的，这样用户可以在测试代码中灵活地控制其生命周期，代码的可测试性更强。</p><p><strong>可测试性</strong>也是架构设计中一个非常重要的指标，易于测试的架构才是优雅的、有生命力的架构。 例如 Netty 中的 <code>EmbeddedChannel</code>，可以让使用者在不进行实际网络调用的情况下测试 Channel 的功能，这部分就不展开了，感兴趣的同学可以去看下 Netty 的单元测试。</p><h3 id="Dubbo-的优雅停机"><a href="#Dubbo-的优雅停机" class="headerlink" title="Dubbo 的优雅停机"></a>Dubbo 的优雅停机</h3><p>Seata 基于 Spring 的优雅停机策略和 Dubbo 的优雅停机策略基本是一样的（注意下面代码中标注[1]和[2]的地方），个人猜测 Seata 大概率是借鉴了 Dubbo，复用了社区或者阿里内部的最佳实践。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringExtensionFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExtensionFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SpringExtensionFactory.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;ApplicationContext&gt; CONTEXTS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashSet</span>&lt;ApplicationContext&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ApplicationListener</span> <span class="hljs-variable">SHUTDOWN_HOOK_LISTENER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShutdownHookListener</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>        CONTEXTS.add(context);<br>        <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> ConfigurableApplicationContext) &#123;<br>            <span class="hljs-comment">// [1] 注册 Spring Context 的 ShutdownHook</span><br>            ((ConfigurableApplicationContext) context).registerShutdownHook();<br>            <span class="hljs-comment">// [2] 取消 Dubbo AbstractConfig 注册的 ShutdownHook 事件</span><br>            DubboShutdownHook.getDubboShutdownHook().unregister();<br>        &#125;<br>        BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownHookListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> &#123;<br>            <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ContextClosedEvent) &#123;<br>                <span class="hljs-type">DubboShutdownHook</span> <span class="hljs-variable">shutdownHook</span> <span class="hljs-operator">=</span> DubboShutdownHook.getDubboShutdownHook();<br>                shutdownHook.doDestroy();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这段代码解决了两个问题：</p><ol><li><p>Dubbo ShutdownHook 和 Spring Context ShutdownHook 重复执行的问题；</p></li><li><p>在使用 SpringBoot 内嵌 Tomcat 容器时，Spring Context 的 <code>registerShutdownHook</code> 方法是会被自动调用的，但使用纯粹的 Spring 框架或者外部 Tomcat 容器时则不会。<br>这里 Dubbo 显示地调用 <code>registerShutdownHook</code>，解决了 Spring ShutdownHook 可能未被注册的问题。</p></li></ol></blockquote><p>想要了解具体细节的同学，可以阅读靖峰大佬的这篇文章 <a href="https://www.cnkirito.moe/dubbo-gracefully-shutdown/">一文聊透 Dubbo 优雅停机</a>，非常详细地介绍了 Dubbo 优雅停机的技术实现和演进历程。</p>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提高代码简洁度的工具类合集</title>
    <link href="/2020/02/24/collection-of-utility-class/"/>
    <url>/2020/02/24/collection-of-utility-class/</url>
    
    <content type="html"><![CDATA[<p>日常开发中整理的一些开箱即用的开源工具类，帮助减少冗余代码和项目中的重复轮子，主要提供商包括 <code>Spring</code>, <code>Apache common-lang3</code>, <code>Lombok</code>, <code>Guava</code>。</p><h1 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// original code</span><br><span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgument</span>(<span class="hljs-string">&quot;given argument must not be null&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (num != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgument</span>(<span class="hljs-string">&quot;given number is not 1&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// clean code, powered by spring-core</span><br>Assert.notNull(input, <span class="hljs-string">&quot;input is null&quot;</span>);<br><br>Assert.isTrue(num == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;given number is not 1&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="Safe-equals"><a href="#Safe-equals" class="headerlink" title="Safe equals"></a>Safe equals</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// not null-safe</span><br>!a.equals(b)<br><br><span class="hljs-comment">// better, powered by JDK-7</span><br>!Objects.equals(a, b)<br></code></pre></td></tr></table></figure><h1 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// common-lang3</span><br>StringUtils.isEmpty(str);<br>StringUtils.isBlank(str);<br></code></pre></td></tr></table></figure><h1 id="BooleanUtils"><a href="#BooleanUtils" class="headerlink" title="BooleanUtils"></a>BooleanUtils</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Boolean b;<br><br><span class="hljs-comment">// original code</span><br><span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// clean code, powered by common-lang3</span><br><span class="hljs-keyword">if</span> (BooleanUtils.isNotTrue) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="defaultIfNull"><a href="#defaultIfNull" class="headerlink" title="defaultIfNull"></a>defaultIfNull</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// defaultIfNull common-lang3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">expiration</span> <span class="hljs-operator">=</span> ObjectUtils.defaultIfNull(<br>                Utils.getConfigValueAsInt(PROPERTY_EXPIRATION),<br>                DEFAULT_EXPIRATION);<br></code></pre></td></tr></table></figure><h1 id="Ignore-Checked-Exception"><a href="#Ignore-Checked-Exception" class="headerlink" title="Ignore Checked-Exception"></a>Ignore Checked-Exception</h1><p>Lombok <code>@SneakyThrow</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">normalMethodWithThrowsIdentifier</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();<br>&#125;<br><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodWithSneakyThrowsAnnotation</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Builder-Pattern-with-Lombok"><a href="#Builder-Pattern-with-Lombok" class="headerlink" title="Builder Pattern with Lombok"></a>Builder Pattern with Lombok</h1><p><a href="https://projectlombok.org/features/Builder">lombok Builder</a></p><h2 id="Required-arguments-with-a-lombok-Builder"><a href="#Required-arguments-with-a-lombok-Builder" class="headerlink" title="Required arguments with a lombok @Builder"></a>Required arguments with a lombok @Builder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Builder;<br><span class="hljs-keyword">import</span> lombok.ToString;<br><br><span class="hljs-meta">@Builder(builderMethodName = &quot;hiddenBuilder&quot;)</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String surname;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PersonBuilder <span class="hljs-title function_">builder</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> hiddenBuilder().name(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copied from <a href="https://stackoverflow.com/questions/29885428/required-arguments-with-a-lombok-builder/30867286#30867286">SOF</a></p><h1 id="guava"><a href="#guava" class="headerlink" title="guava"></a>guava</h1><p>TODO</p><h1 id="retry-strategy"><a href="#retry-strategy" class="headerlink" title="retry strategy"></a>retry strategy</h1><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>CleanCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CleanCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次有趣的代码重构</title>
    <link href="/2020/02/14/a-funny-code-refactor/"/>
    <url>/2020/02/14/a-funny-code-refactor/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我等采石之人，当心怀建造大教堂之愿景。<br>——《程序员修炼之道》</p></blockquote><p>发现代码重构和灭霸的响指有一个共同点，两者的出发点都是为了消除系统之中的一部分，让剩下的另一部分存活得更好，从而使得整个系统运更为有序。  </p><p>不同之处就是灭霸是无差别清除，而重构对于代码的清除却是经过深思熟虑精心设计的。  </p><p>闲话少说，下面开始正题。</p><h2 id="重构前"><a href="#重构前" class="headerlink" title="重构前"></a>重构前</h2><p>背景是足球比赛的项目，需要处理各种类型的比赛数据。</p><p>比赛数据的展示维度如图：<br><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703ef2678ba061f?w=1640&h=332&f=png&s=61336"></p><p>用代码表示是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示一场比赛里两支球队各个阶段的数据</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MatchStat</span> &#123;<br>    <span class="hljs-keyword">private</span> TeamStat homeTeamStat;<br>    <span class="hljs-keyword">private</span> TeamStat guestTeamStat;<br>&#125;<br><br><span class="hljs-comment">// 一支球队各个阶段的数据</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TeamStat</span> &#123;<br>    <span class="hljs-comment">/** 上半场的数据 */</span><br>    <span class="hljs-keyword">private</span> Stat firstStageStat;   <br>    <span class="hljs-comment">/** 下半场的数据 */</span><br>    <span class="hljs-keyword">private</span> Stat secondStageStat;   <br>    <span class="hljs-comment">/** 全场的数据 */</span><br>    <span class="hljs-keyword">private</span> Stat fullStageStat;   <br>&#125;<br><br><span class="hljs-comment">// 这个是表示比赛数据的 Model</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stat</span> &#123;<br>    <span class="hljs-comment">/** 得分 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-comment">/** 传球数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pass;<br>    <span class="hljs-comment">/** 抢断数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> steal;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，项目中存在很多种比赛数据类型，如：  </p><blockquote><p>HeartIntensity 心率强度;<br>ExerciseLoad 负荷强度;<br>DistanceSpeed 跑动距离-速度分布;<br>DistanceTime 跑动距离-速度分布;<br>……</p></blockquote><p>对于每种数据类型 Model，如 <code>ExerciseLoad</code>，都要再定义一个 TeamModel，如 <code>TeamExerciseLoad</code>，表示一只球队比赛各阶段的数据，<br>然后再定义一个 MatchModel, 如 <code>MatchExerciseLoad</code>，表示一场比赛中两队各阶段的数据。  </p><p>那么，N 种数据类型的话，一共就要定义 3 * N 个 Model 类。</p><p><strong>问题一：是不是有办法减少 Model 类的数量呢？</strong></p><p>我们暂时先不管这个问题，继续往下看，如果有这样一个需求，我们拿到一个 <code>MatchStat</code> 对象，要把两队所有阶段的传球数都设为 0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMatchStat</span><span class="hljs-params">(MatchStat matchStat)</span> &#123;<br>    <span class="hljs-comment">// 如何实现这个需求呢？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之前在项目里一般是这样处理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 定义一个方法处理单队的数据</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">processTeamStat</span><span class="hljs-params">(TeamStat teamStat)</span> &#123;<br>    teamStat.getFirstStageStat().setPass(<span class="hljs-number">0</span>);<br>    teamStat.getSecondStageStat().setPass(<span class="hljs-number">0</span>);<br>    teamStat.getFullStageStat().setPass(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMatchStat</span><span class="hljs-params">(MatchStat matchStat)</span> &#123;<br>    <span class="hljs-comment">// 2. 分别传入主客队的 TeamModel 作为入参, 调用上面那个方法</span><br>    processTeamStat(matchStat.getHomeStat());<br>    processTeamStat(matchStat.getGuestStat());<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码看似没有问题，也没有一行重复代码，这种类似的需求（处理两队各个阶段的比赛数据）在项目里还是不少的，可是每次都这样写一遍不免有些枯燥。<br>显示的重复代码确实找不到，但是“隐式”的重复代码呢？</p><p><strong>问题二：有没有办法简化项目里的这种模版代码?</strong></p><h2 id="重构后"><a href="#重构后" class="headerlink" title="重构后"></a>重构后</h2><p>下面揭示答案，直接贴出重构后的处理方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMatchStat</span><span class="hljs-params">(TwoTeamNestedAllStageModel&lt;Stat&gt; matchStat)</span> &#123;<br>    <span class="hljs-comment">// 一行代码解决问题!</span><br>    ModelUtils.handleTwoTeamNestedAllStageModel(matchStat, (stat) -&gt; stat.setPass(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是简洁了很多，枯燥指数大大降低。</p><p><strong>实现细节</strong>： </p><h3 id="减少-model-类的数量"><a href="#减少-model-类的数量" class="headerlink" title="减少 model 类的数量"></a>减少 model 类的数量</h3><p>定义两个通用的 Model：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoTeamNestedAllStageModel</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> AllStageModel&lt;T&gt; home;<br>    <span class="hljs-keyword">private</span> AllStageModel&lt;T&gt; guest;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoTeamNestedAllStageModel</span><span class="hljs-params">(AllStageModel&lt;T&gt; home, AllSatgeModel&lt;T&gt; guest)</span> &#123;<br>        <span class="hljs-built_in">this</span>.home = home;<br>        <span class="hljs-built_in">this</span>.guest = guest;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> AllStageModel&lt;T&gt; <span class="hljs-title function_">getHome</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> home;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> AllStageModel&lt;T&gt; <span class="hljs-title function_">getGuest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> guest;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Value</span> <span class="hljs-comment">// lombok will generate consructor and getters</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllStagetModel</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T firstStage;<br>    <span class="hljs-keyword">private</span> T secondStage;<br>    <span class="hljs-keyword">private</span> T fullStage;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TwoTeamNestedAllStageModel</code> 和 <code>AllStageModel</code> 可以看成是一种容器类，有点类似于 JDK 里的 <code>List</code> 和 <code>Map</code>。  </p><p>以 <code>ExerciseLoad</code> 这个 Model 为例，我们原先需要定义 <code>TeamExerciseLoad</code> 和 <code>MatchExerciseLoad</code> 两个类。   </p><p>现在有了这两个“容器 Model”，我们就只需要声明一个 <code>TwoTeamNestedAllStageModel&lt;ExerciseLoad&gt;</code> 就行了，<br>这样项目里一下子就减少了 2 * N 个 Model 类，省去了重复定义这些 Model 的枯燥工作。</p><p>这就回答了刚才提出的问题一。</p><p>下面我们来接着回答问题二：</p><h3 id="消除“隐式”的重复代码"><a href="#消除“隐式”的重复代码" class="headerlink" title="消除“隐式”的重复代码"></a>消除“隐式”的重复代码</h3><p>借助“容器 Model”我们把这些模版代码都提取到一个工具类里了，通过这种方式消除了”隐式“的重复代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelUtils</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">processTwoTeamNestedAllStageModel</span><span class="hljs-params">(</span><br><span class="hljs-params">        TwoTeamNestedAllStageModel&lt;T&gt; m, java.util.function.Consumer&lt;T&gt; action)</span> &#123;<br>        processAllStageModel(m.getHome(), action)<br>        processAllStageModel(m.getGuest(), action)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; processAllStageModel(<br>        AllStageModel&lt;T&gt; m, java.util.function.Consumer&lt;T&gt; action) &#123;<br>        action.accept(m.getFirstStage());<br>        action.accept(m.getSecondStage());<br>        action.accept(m.getFirstStage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>业务开发不仅仅是简单的 CURD，我们在开发的过程中，针对不同的业务场景其实有很多地方是可以归纳提炼的，让自己的代码更加简洁优雅，<br>切记不要惰于思考，只是凭直觉简单地堆砌代码、面向任务编程。   好的代码都是设计出来的。  </p><p>我们要以工程师和设计师的身份自居，培养自己对于坏代码、重复代码的敏锐嗅觉，逐步提升自己的代码品味。</p><p>好处:</p><ul><li>Model 类的数量减少了 2 &#x2F; 3，处理这些 model 类的方式也更简单了，提升了代码的简洁度，提高了编码效率</li></ul><p>坏处：</p><ul><li>比起之前的代码，重构后的 Model 定义和使用方式具有一定的学习成本</li><li>如果 Model 类不是很多的话，重构的收益其实有限，有过度设计的嫌疑</li><li>代码量变少了，“每千行 Bug 数”提升了，老板可能觉得你的工作效率和质量下降了（手动狗头）</li></ul>]]></content>
    
    
    <categories>
      
      <category>CleanCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CleanCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大搜车异步任务队列中间件的建设实践</title>
    <link href="/2019/08/20/souche-task-queue/"/>
    <url>/2019/08/20/souche-task-queue/</url>
    
    <content type="html"><![CDATA[<p>本文源自于一次部门内部的技术分享，首发于部门的<a href="https://mp.weixin.qq.com/s/DvuRdY74C0xO_fLVF7lONg">微信公众号</a>，后被 <a href="https://www.infoq.cn/article/uMQb2CFDgRFcDUz9OFD1">InfoQ</a> 转载。</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>异步任务处理在系统设计中是一个十分常见的场景, 例如将耗时任务异步化, 流量削峰, 接口的延时回调等等。</p><p>对于异步任务, 最最常见的一种实现方式就是 JDK 的线程池了, 使用线程池可以满足大多数异步化的场景, 但它还是有一些局限性:</p><ul><li><p>一方面它是基于内存的, 一旦机器宕机异步任务就丢失了, 可靠性不足;</p></li><li><p>另一方面它是单机处理任务, 不适合分布式场景, 当单机处理任务的能力不足时，无法水平拓展</p></li></ul><p>而对于分布式异步任务的处理需求, 我们通常使用 MQ 来实现分布式异步处理: 生产者将异步任务以消息的形式丢入消息队列, 消费者异步地从消费队列里获取消息进行任务处理。</p><p><img src="https://static001.infoq.cn/resource/image/a5/c8/a56c48176d25c1340c465c54c527bac8.png"></p><p>这也是大多数 Java 程序员的选择, 但是使用 MQ 实现异步队列也存在一些不足之处:</p><ul><li><p>基于 MQ 开发异步任务还是有些复杂的, 开发人员需要写不少业务逻辑之外的代码, 理想的状态是, 开发人员可以专注于任务处理本身的业务逻辑, 将维护异步化操作这类的系统控制交给中间件来完成；</p></li><li><p>功能局限性：比如基于 MQ 无法实现任意大小的延时时间、自定义重试策略、复杂的任务调度场景——如依赖任务等；</p></li><li><p>缺少一个可视化的页面查看任务执行情况, 包括有哪些任务正在执行, 正在哪台机器上执行, 已成功 &#x2F; 失败的任务等等</p></li></ul><p>放眼其他语言的异步任务队列, 我们知道 Python 有 <code>Celery</code>, Ruby 有 <code>Sidekiq</code>, 使用起来非常轻量级，只需要额外做一些简单的配置, 就能像调用本地方法一样调用异步任务的执行逻辑。</p><p>所以, 为了解决基于 MQ 开发异步任务过于复杂的问题, 让 Java 程序员也能使用轻量级的异步任务队列, Optimus-AsyncTask 便应运而生了。</p><p>Optimus-AsyncTask 是我们公司的中间件团队研发的一款分布式异步任务中间件, 追求轻量级和高性能, 特点是配置简单, 功能丰富, 编程模型简单, 可以像调用本地方法一样调用异步任务, 让开发同学可以专注于业务逻辑的开发, 提高开发效率。</p><p>在介绍 Optimus-AsyncTask 之前, 我们先探讨一下分布式任务队列需要具备的功能点, 以及实现一个分布式任务队列需要注意的一些地方:</p><h2 id="如何设计一个分布式异步任务队列"><a href="#如何设计一个分布式异步任务队列" class="headerlink" title="如何设计一个分布式异步任务队列"></a>如何设计一个分布式异步任务队列</h2><ul><li><p>支持高并发<br>能够支持至少万级的 QPS</p></li><li><p>任务持久化<br>常见的数据存储中间件, 如数据库, Redis, 或者 MQ</p></li><li><p>任务状态流转<br>在一个任务的生命周期中可能存在多个状态, 这些状态包括: 准备执行, 正在执行, 执行结束 (成功), 执行失败之后进入待重试状态, 执行失败后进入死亡状态等等.<br>在状态流转的过程中, 需要保证数据的一致性</p></li><li><p>可靠性保障<br>保证任务不丢失, 任务不被重复执行</p></li><li><p>支持水平拓展<br>可以动态地添加执行器</p></li><li><p>合理的负载策略<br>可以合理地分配执行资源, 保证各个执行器对任务进行有效的负载</p></li><li><p>支持重试机制<br>用户可以配置重试次数, 在任务执行失败或超时的时候进行自动重试</p></li><li><p>幂等性支持<br>保证幂等性是分布式场景中的一个重要课题, 可以在异步任务中间件里提供幂等性支持:<br>用户提交任务时提供一个业务 ID, 业务 ID 相同的任务只会执行一次</p></li><li><p>友好的 API<br>对用户屏蔽异步任务的底层实现细节, 像调用本地方法一样调用异步方法</p></li><li><p>提供控制台查看任务状态</p></li></ul><h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><p>在抛出以上几个问题之后, 下面我们开始介绍 Optimus-AsyncTask 的具体实现:</p><h3 id="任务生命周期"><a href="#任务生命周期" class="headerlink" title="任务生命周期"></a>任务生命周期</h3><p>任务执行超时 &#x2F; 失败之后会进入“重试”队列等待下一次执行, 超时 &#x2F; 失败次数超过用户设置的最大重试次数之后任务就会变成“死亡”状态, 结束生命周期</p><p><img src="https://static001.infoq.cn/resource/image/e0/5d/e00b6715e2cf58cf1b4df48601b76e5d.png" alt="alt"></p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="https://static001.infoq.cn/resource/image/a2/4d/a2cea599dc1b6eb8eb6fde7a82cead4d.png"></p><p>一个集群 (每个应用实例的代码都是相同的) 配置一个 Redis, 一个机器提交任务, 任意一台机器执行。</p><h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交:"></a>任务提交:</h4><p>SDK 向 Redis 提交任务, 普通异步任务的初始状态为 ready, 延时任务为 delayed。</p><h4 id="任务状态变更"><a href="#任务状态变更" class="headerlink" title="任务状态变更:"></a>任务状态变更:</h4><p>SDK 不断轮询 Redis, 修改任务的状态:</p><p>delayed -&gt; ready (延时任务到达执行时间)</p><p>retry -&gt; ready (重试任务到达执行时间)</p><p>ready -&gt; working (开始执行任务)</p><p>working -&gt; retry&#x2F;dead (任务执行超时进入重试或者死亡状态)</p><h4 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行:"></a>任务执行:</h4><p>SDK 将任务的状态从 ready 修改为 working 后, 从 Redis 中获取该任务信息, 在本地执行任务。</p><h4 id="执行结果上报"><a href="#执行结果上报" class="headerlink" title="执行结果上报:"></a>执行结果上报:</h4><p>任务执行结束后, SDK 向 Redis 上报执行结果, 修改任务的状态:</p><p>working -&gt; success (执行成功)</p><p>working -&gt; retry&#x2F;dead (执行失败)</p><p>SDK 中专门开辟了一个线程池用来执行异步任务, 执行线程池的线程数量是开放给用户配置的, SDK 只有在本地存在空闲线程时才去获取任务, 由此可以保证对执行资源的有效分配。</p><h3 id="任务存储"><a href="#任务存储" class="headerlink" title="任务存储"></a>任务存储</h3><p>首先, 为了保障高性能, 我们选择 Redis 作为任务存储层。</p><h4 id="Redis-vs-MySQL"><a href="#Redis-vs-MySQL" class="headerlink" title="Redis vs MySQL"></a>Redis vs MySQL</h4><p>我们观察到市场上的一些开源 Java 异步任务中间件 (如 jmppok&#x2F;AsyncTask, bojiw&#x2F;asyncmd) 都是基于 MySQL 的, 选择 MySQL 的好处是, 基于关系型数据库我们可以很方便地实现任务查询和任务状态流转:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> task <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ready&#x27;</span>;<br><span class="hljs-keyword">UPDATE</span> task <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;working&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>像这样通过简单的 SQL 就可以实现, 开发成本较低。</p><p>但如果使用 Redis 的话, 因为 Redis 的数据结构较为简单, 不适合 MySQL 这种条件查询和数据嵌套 (为了让一个 Task 元素包含多个属性字段, 在 Redis 里只能用 JSON 字符串来表示), 为了实现相同的语义, 需要设计更复杂的数据结构 (下文会具体介绍), 开发成本更高。</p><p>但即便如此, 我们依然选择 Redis 而不是 MySQL, 主要还是考虑到 MySQL 对高并发的支持不是很好, 在我们公司的 C 端场景下异步任务的提交频率会很高, 所以高并发场景是我们必须要考虑的。</p><p>此外, 选择 MySQL 的话, 还需要创建额外的表, 对业务数据库有一定的侵入性。</p><h4 id="Redis-vs-MQ"><a href="#Redis-vs-MQ" class="headerlink" title="Redis vs MQ"></a>Redis vs MQ</h4><p>我们没有使用 MQ 作为任务存储层是因为 MQ 的运维流程比较复杂, 需要事先申请 Topic, 消费组等信息, 没有 Redis 那么轻量。</p><p>并且，基于 MQ 实现的任务队列具有一定的功能局限性，例如无法实现任意大小的延时时间、自定义重试策略、复杂的任务调度场景——如依赖任务等。</p><h3 id="Redis-数据结构设计"><a href="#Redis-数据结构设计" class="headerlink" title="Redis 数据结构设计"></a>Redis 数据结构设计</h3><p>一种任务状态对应一个 Redis 集合, 任务数据以 JSON 字符串的形式存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">[zset] delayed (延时任务), retry (待重试任务). zset 的 score 是预期执行时间, value 是任务数据<br><br>[hash] working (正在执行中的任务). hash 的 field 代表任务 ID, value 表示任务数据 (json 字符串的形式))<br><br>[list] ready (就绪的任务)<br>[list] success:&#123;date&#125; (处理完成的任务，每天生成一个 list, value 是任务信息，默认过期时间 <span class="hljs-number">14</span> 天)<br>[list] dead:&#123;date&#125; (死亡任务: value 是任务信息，默认过期时间 <span class="hljs-number">14</span> 天)<br></code></pre></td></tr></table></figure><h3 id="原子性保障"><a href="#原子性保障" class="headerlink" title="原子性保障"></a>原子性保障</h3><p>每次切换任务状态, 至少需要三个步骤:</p><ol><li><p>从原来的集合里删除元素 ;</p></li><li><p>对于取出的任务数据, 修改 JSON 的部分 value, 也就是任务的属性, 如 ‘executionTime’, ‘finishTime’ 等 ;</p></li><li><p>将元素加入到新的集合里。</p></li></ol><p>为了保证操作的原子性, 需要使用 lua 脚本来变更任务状态, 例如从 ready 切换到 working 状态, 对应的 lua 伪代码如下:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- ready(list) to working(hash)</span><br><span class="hljs-keyword">local</span> src = KEYS[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> dest = KEYS[<span class="hljs-number">2</span>]<br><span class="hljs-keyword">local</span> currTime = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> clientId = ARGV[<span class="hljs-number">2</span>]<br><br><span class="hljs-comment">-- get json and delete from &#x27;ready&#x27;</span><br><span class="hljs-keyword">local</span> srcJson = redis.call(<span class="hljs-string">&#x27;LPOP&#x27;</span>, src)<br><span class="hljs-keyword">if</span> (srcJson == <span class="hljs-literal">false</span>) <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- update &#x27;executionTime&#x27; and &#x27;clientId&#x27; fields of json</span><br><span class="hljs-keyword">local</span> destTask = &#123;&#125;<br><span class="hljs-keyword">local</span> srcTask = cjson.decode(srcJson)<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(srcTask) <span class="hljs-keyword">do</span><br>    destTask[k] = v<br><span class="hljs-keyword">end</span><br>destTask[<span class="hljs-string">&#x27;executionTime&#x27;</span>] = currTime<br>destTask[<span class="hljs-string">&#x27;clientId&#x27;</span>] = clientId<br><span class="hljs-keyword">local</span> destJson = cjson.encode(destTask)<br><br><span class="hljs-comment">-- add into &#x27;working&#x27;</span><br>redis.call(<span class="hljs-string">&#x27;HSET&#x27;</span>, dest, destTask[<span class="hljs-string">&#x27;taskId&#x27;</span>], destJson)<br><br><span class="hljs-keyword">return</span> destJson<br></code></pre></td></tr></table></figure><p>借助 Redis 的原子性特性, 对于一个任务, 可以保证只有一台机器能够成功获取到该任务, 从而保证该任务不会在多台机器上重复执行。</p><hr><h3 id="高可用保障"><a href="#高可用保障" class="headerlink" title="高可用保障"></a>高可用保障</h3><h4 id="轮询时间间隔"><a href="#轮询时间间隔" class="headerlink" title="轮询时间间隔"></a>轮询时间间隔</h4><p>为了防止机器数量增加导致访问 Redis 过于频繁, 所以根据机器的数量来动态调整轮询的间隔时间, 并且加入随机因子让每次间隔时间都是随机变化的，保证各台机器可以错开访问，防止类似雪崩之类的系统故障。</p><p>设 avgInterval 为 15 秒, random 是随机变量, 取值范围为 [0, 1], size 是客户端机器数<br>每台机器实际的轮询时间间隔为：avgInterval * (1&#x2F;2 + random) * size</p><p>在概率统计的意义上, 对整个机器集群来讲，整体的平均轮询间隔时间为 15 秒。</p><h4 id="任务重试的等待时间"><a href="#任务重试的等待时间" class="headerlink" title="任务重试的等待时间"></a>任务重试的等待时间</h4><p>任务失败后需要等一段时间再重试执行, 这里借鉴了 Sidekiq 的实现方式, 等待时间的计算方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// retryCount 是重试次数, random 是随机变量, 取值范围为 [0, 1]</span><br>retryCount ^ <span class="hljs-number">4</span> + <span class="hljs-number">15</span> + random * <span class="hljs-number">30</span> * (retryCount + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>等待时间以指数级的形式增长, 之所以加入了随机变量是为了防止这样一种情况:<br>多个异步任务的执行时间相隔很近, 访问某一个资源, 由于并发访问的原因, 资源提供方的负载过高, 导致这些异步任务都执行失败, 如果任务重试的等待时间里没有加入随机因子的话, 这几个任务又会在相近的时间内一起执行, 并发访问资源, 由于同样的原因导致任务执行失败, 如此反复。<br>加入随机因子可以错开这些任务的执行时间, 避免这种情况的出现。</p><h4 id="状态上报失败后的重试补偿"><a href="#状态上报失败后的重试补偿" class="headerlink" title="状态上报失败后的重试补偿"></a>状态上报失败后的重试补偿</h4><p>任务执行结束后需要上报成功 &#x2F; 重试 &#x2F; 死亡的状态, 但由于网络原因可能导致访问 Redis 失败, 当出现上报失败时, SDK 会将此次上报放到一个内存队列里, 通过后台的定时任务, 不断地重试上报过程。</p><hr><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><h4 id="开发一个异步任务"><a href="#开发一个异步任务" class="headerlink" title="开发一个异步任务:"></a>开发一个异步任务:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@OpAsyncTask(timeout = 600, maxRetry = 3)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoAsyncTaskHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BaseAsyncTaskHandler</span>&lt;CustomPOJO&gt; &#123;<br><br>    <span class="hljs-comment">// 可以在 TaskHandler 里注入其他 bean</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DemoDao demoDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAsync</span><span class="hljs-params">(CustomPOJO params)</span> &#123;<br>        <span class="hljs-comment">// 任务的执行逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务方需要实现这个回调方法，根据自己传给 perform 方法的 params 参数，返回一个 bizId,</span><br><span class="hljs-comment">     * 以实现任务去重: 对于一个 taskHandler, 多次提交 bizId 相同的任务, 框架只会执行一次。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> params 调用方传给 perform 方法的参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBizId</span><span class="hljs-params">(CustomPOJO params)</span> &#123;<br>        <span class="hljs-comment">// 基于 params 参数生成 bizId</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="提交异步任务"><a href="#提交异步任务" class="headerlink" title="提交异步任务:"></a>提交异步任务:</h4><p>就像调用一个普通的本地方法 (基于 Spring 动态代理实现)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoService</span> &#123;<br><br>    <span class="hljs-comment">// TaskHandler 就是一个 Spring Bean, 你可以像注入其他 Bean 一样注入 TaskHandler</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DemoAsyncTaskHandler asyncTaskHandler;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提交普通异步任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAsync</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CustomPOJO</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomPOJO</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        asyncTaskHandler.performAsync(param);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Web-控制台"><a href="#Web-控制台" class="headerlink" title="Web 控制台"></a>Web 控制台</h3><p>查看任务的执行状态</p><p><img src="https://static001.infoq.cn/resource/image/48/e3/4822519f57b4d0aae34fd501d5fd29e3.jpg"></p><hr><h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><h3 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h3><p>除了上文提到的普通异步任务和延时任务, 我们还提供了一种任务依赖的功能, 使用场景如下:</p><p>例如 A 任务和 B 任务都是外部系统触发的, 但是 B 任务需要在 A 任务执行结束后才能执行成功, A, B 触发时机的先后次序是不一定的, B 的触发时机可能会先于 A 的, 这个时候 B 任务没法立即执行, 需要等待 A 的完成。</p><p>这些任务执行次序的逻辑控制由业务方实现的话会比较麻烦, 可以交给 OpAsyncTask 来完成:<br>把 A 和 B 声明为依赖任务, 且 B 依赖于 A, 在被外部系统触发时, 分别提交 A 任务和 B 任务, A 和 B 的执行次序交给 OpAsyncTask 来协调, 业务方只要专注于任务本身的处理逻辑就可以了。</p><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>当在 Spring 的事务内调用 TaskHandler 的 perform* 方法 (既提交任务) 时,<br>如果执行出现异常导致事务回滚操作, 那么异步任务提交也会回滚, 既任务不会被提交 ;<br>如果执行正常, 那么事务正常提交后, 异步任务就会被正常提交。</p><p><strong>实现原理:</strong> 在 TaskHandler 的 perform* 方法被调用时, OpAsyncTask 会判断当前线程是否处于 Spring 事务中, 如果不是的话就直接提交异步任务, 如果是的话会“延迟提交异步任务” —— 事务成功提交之后再去提交异步任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// delay the submitting if it&#x27;s in a transaction</span><br><span class="hljs-keyword">if</span> (TransactionSynchronizationManager.isActualTransactionActive()) &#123;<br>    log.info(<span class="hljs-string">&quot;It&#x27;s in a active transaction, delay the task submitting&quot;</span>);<br>    TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionSynchronizationAdapter</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> &#123;<br>            log.info(<span class="hljs-string">&quot;Submitting async task after committing transaction&quot;</span>);<br>            submitAsyncTask();<br>        &#125;<br>    &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    log.info(<span class="hljs-string">&quot;It&#x27;s not in a active transaction, submit task directly&quot;</span>);<br>    submitAsyncTask();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项:</strong> 本质上把异步任务的提交行为推迟到事务成功提交之后执行, 所以异步任务的提交这一行为和事务中的行为 (如 DB 操作) 不是原子性的 (要么都成功执行, 要么都不执行), 最终提交异步任务时有可能因为网络原因导致异步任务提交失败, 这时候事务已经提交了, 其他事务行为已经生效了, 例如 DB 操作都已生效, 可异步任务没有成功提交, 所以无法严格保证其同时成功执行:<br>事务行为不成功的话, 异步任务提交一定不成功 ; 但事务行为成功的话, 有一定概率出现异步任务提交不成功的情况。</p>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程随想录 — 代码注释</title>
    <link href="/2019/07/02/about-code-comment/"/>
    <url>/2019/07/02/about-code-comment/</url>
    
    <content type="html"><![CDATA[<p>关于代码注释应该有不少书籍讨论过了, 比如《Clean Code》, 这里我还是想结合一些个人经验, 简单表达一些关于代码注释最佳实践的看法.<br>关于注释我们在项目中可能会遇到如下几种情况:</p><h2 id="无用的注释"><a href="#无用的注释" class="headerlink" title="无用的注释"></a>无用的注释</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f1f0a34f7c67?w=1080&h=1119&f=jpeg&s=110638"></p><p>《Clean Code》里列举了很多种Bad Comments, 其中就包括Noise Comments:</p><blockquote><p>Sometimes you see comments that are nothing but noise. They restate the obvious and provide no new information.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** The day of the month. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> dayOfMonth;<br></code></pre></td></tr></table></figure><p>《Clean Code》也吐糟了 Java Doc 注释的滥用, 作者并不认同每个字段和方法都必须写注释, 因为类似于下面的这种注释是毫无意义的, 在代码之外并没有提供更多的信息. 代码的简单“镜像”? 意义真的不是很大.</p><p>但是很多知名的开源框架还是奉行奉行每个字段和方法都必须有注释的原则, 如<code>Spring</code>, <code>Apache Common</code>, 这样做是考虑到生成 Java Doc 后便于大家阅读文档, 也有它存在的合理性吧. </p><p>总之, 注释的原则是让人更好地理解代码, 如果做不到这点, 就不是好的注释.</p><h2 id="必要的注释"><a href="#必要的注释" class="headerlink" title="必要的注释"></a>必要的注释</h2><p>贴心的注释, 解释代码的动机, 方便后来者阅读, 不需要大家去猜代码, 程序员的沟通原则就是简单直接高效, 编码不是谈恋爱, 有话直说不要靠猜. </p><p>告诉你为什么要加<code>@SuppressWarnings</code>注解:<br><img src="https://user-gold-cdn.xitu.io/2019/7/2/16bb275ead0e0bc0?w=1664&h=576&f=png&s=125259"></p><p>告诉你这段代码的意图:<br><img src="https://user-gold-cdn.xitu.io/2019/7/2/16bb281ae2597b11?w=1796&h=1312&f=png&s=222114"></p><h2 id="几乎不写注释"><a href="#几乎不写注释" class="headerlink" title="几乎不写注释"></a>几乎不写注释</h2><p>我个人就很鄙视这种情况, 包括git commit messeage写得非常很少很简单的情况, 明明修改了很多地方, 却只简单地几个字带过, 这种系统很难维护, 代码意图基本靠猜, 会让接管代码的人很崩溃.   </p><p>我称这种人为时间杀手或者偷时间的人, 这样的代码会让维护者花更多的时间猜测代码的意图, 甚至会让维护者被被过分简单的注释所误导而走不少弯路, 成功地浪费了维护者的工作效率.</p><h3 id="不写注释的一些原因"><a href="#不写注释的一些原因" class="headerlink" title="不写注释的一些原因:"></a>不写注释的一些原因:</h3><ul><li><p><strong>没有写注释的意识</strong>: 技术短视, 没有意识到自己的代码写出来不仅仅是能完成功能的, 还是要给人阅读和维护的. </p></li><li><p><strong>懒得写注释</strong>: 缺乏协作精神，只图自己省事, 哪管他人维护不易</p></li><li><p><strong>用”好的代码是不需要注释的”来为自己不写注释的行为开脱</strong>:<br>  确实好的代码本身很多时候可以清晰地表达出自己在做什么, 但有时却无法表达自己这样做的原因, 这时候注释的作用就体现出来了.<br>  记住: 在表意方面, 代码不是万能的. 代码不够, 注释来凑, 不是什么丢人的事情.<br>  不要写坏注释不等于不写注释</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CleanCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CleanCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TDD 在企业开发中的实践</title>
    <link href="/2019/04/04/tdd-in-enterprice/"/>
    <url>/2019/04/04/tdd-in-enterprice/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>Why<br>  我们为什么要花额外的时间写测试，自动化测试可以给我们带来什么好处?</p></li><li><p>How<br>  分享测试方法论和一些测试实践, 在企业级项目中如何做好测试, 网上多是 Hello World 级别的测试 Demo， It’s not enough!</p></li></ul><h2 id="为什么写测试？"><a href="#为什么写测试？" class="headerlink" title="为什么写测试？"></a>为什么写测试？</h2><p>为什么花这么大精力写测试，需要利益驱动</p><p>测试用例扮演的角色：</p><ol><li>⛑️保护网</li><li>💡引路人</li></ol><h3 id="1-提高项目质量"><a href="#1-提高项目质量" class="headerlink" title="1. 提高项目质量"></a>1. 提高项目质量</h3><h4 id="可靠性交付"><a href="#可靠性交付" class="headerlink" title="可靠性交付"></a>可靠性交付</h4><p>代码质量保障  </p><p>自动化回归测试, 第一时间发现问题</p><p>对于黑盒测试和接口测试很难覆盖到的地方，可以进行细粒度&#x2F;模块化的测试，我们可以对系统进行拆分, 针对某个模块进行测试</p><h4 id="提高代码质量"><a href="#提高代码质量" class="headerlink" title="提高代码质量"></a>提高代码质量</h4><p>测试是重构的前提: “测试保护网” 让人放心重构 —— 重构是避免代码逐步腐化的必要手段</p><h4 id="测试即文档"><a href="#测试即文档" class="headerlink" title="测试即文档"></a>测试即文档</h4><p>测试是<strong>可执行</strong>的文档<br><strong>doc.txt vs doc.exe</strong></p><p>并且，采用 BDD 风格写的测试用例的可读性更强，代码的可维护性更好</p><h4 id="提高开发效率"><a href="#提高开发效率" class="headerlink" title="提高开发效率"></a>提高开发效率</h4><p>降低代码维护成本 (降低自己在项目中的地位🐶) , 提高后期开发迭代效率</p><h3 id="2-自我提升"><a href="#2-自我提升" class="headerlink" title="2. 自我提升"></a>2. 自我提升</h3><h4 id="测试驱动设计"><a href="#测试驱动设计" class="headerlink" title="测试驱动设计"></a>测试驱动设计</h4><p>写出可测试性的代码, 提升模块化设计的能力，思考功能的边界、模块的松耦合, 加深对项目的理解</p><h4 id="测试驱动成长"><a href="#测试驱动成长" class="headerlink" title="测试驱动成长"></a>测试驱动成长</h4><ul><li>测试是必备技能，是持续集成的基础，几乎所有讲敏捷开发的书都会提到 TDD</li><li>加深对各类技术的理解, 强迫你打开盒子，研究原理, e.g. 加深对 Spring 的理解</li></ul><hr><p>如何更好地写测试?</p><h2 id="TDD-开发模式"><a href="#TDD-开发模式" class="headerlink" title="TDD 开发模式"></a>TDD 开发模式</h2><blockquote><p>TDD 有广义和狭义之分，常说的是狭义的 TDD，也就是 UTDD（Unit Test Driven Development）。<br>广义的 TDD 是 ATDD（Acceptance Test Driven Development），包括 BDD（Behavior Driven Development）和 Consumer-Driven Contracts Development 等。</p><p>TDD(单元测试驱动开发) 是敏捷开发中的一项核心实践和技术，也是一种设计方法论。<br>TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。<br>TDD 是 XP（Extreme Programming）的核心实践。它的主要推动者是 Kent Beck。 </p></blockquote><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><ul><li>提前澄清需求, 明确流程，</li><li>测试不再成为一种负担, 而是设计的一部分</li><li>帮助开发人员做更好设计(代码职责更明确，代码可测试性更强)</li><li>快速反馈</li></ul><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p><img src="https://upload-images.jianshu.io/upload_images/279826-49f2f708aefb567f" alt="the process of TDD"></p><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><ul><li>red: 明确意图; 保证测试代码抛出预期的错误（对测试的测试）</li><li>green<ul><li>快速实现</li><li>实现真正的产品代码</li></ul></li><li>refactor</li></ul><h3 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h3><ul><li>提前设计, 划分好任务的粒度, 小步走</li><li>严格按照”先测试再实现”的顺序</li></ul><hr><p>介绍完 TDD，我们来进行测试方法论及最佳实践的探讨，最终目标：</p><ul><li>测试的完备性：如何更好地保护代码</li><li>开发效率：通过最佳实践、工具选择等减轻写测试的负担</li><li>测试代码可读性和可维护性</li></ul><h2 id="测试方法论"><a href="#测试方法论" class="headerlink" title="测试方法论:"></a>测试方法论:</h2><h3 id="分类原则"><a href="#分类原则" class="headerlink" title="分类原则"></a>分类原则</h3><p>优先按“主题” (系统模块, Feature, Bug) 分类, 其次才是 Class</p><h3 id="集成测试和单元测试的关系"><a href="#集成测试和单元测试的关系" class="headerlink" title="集成测试和单元测试的关系"></a>集成测试和单元测试的关系</h3><p>举个例子，比如要测试这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeAndDeliverCake</span><span class="hljs-params">(FlavorEnum flavor)</span> &#123;<br>    <span class="hljs-comment">// 耗时短，测试用例复杂</span><br>    <span class="hljs-type">Cake</span> <span class="hljs-variable">cake</span> <span class="hljs-operator">=</span> makeCake(flavor);<br><br>    <span class="hljs-comment">// 耗时长，测试用例简单</span><br>    deliverCake(cake);<br>&#125;<br></code></pre></td></tr></table></figure><p>test <code>makeCake</code>: </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;succeed to makeCake&quot;</span>() &#123;<br>    <span class="hljs-symbol">when:</span><br>    Cake actualCake = makeCake(falvor)<br>    <span class="hljs-symbol">then:</span><br>    expectedCake == actualCake<br><br>    <span class="hljs-symbol">where:</span><br>    falovr | expectedCake<br>    apple  | appleCake<br>    banana | bananaCake<br>    orange | orangeCake<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;failed to makeCake: 库存不足&quot;</span>() &#123;<br>    <span class="hljs-symbol">when:</span><br>    Cake actualCake = makeCake(falvor)<br>    <span class="hljs-symbol">then:</span><br>    <span class="hljs-keyword">def</span> e = thrown(IllegalArgumentException)<br>    e.message == <span class="hljs-string">&#x27;库存不足&#x27;</span><br><br>    <span class="hljs-symbol">where:</span><br>    falovr &lt;&lt; [mango, grape]  <br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;failed to makeCake: 暂不支持这种口味&quot;</span>() &#123;<br>    <span class="hljs-symbol">when:</span><br>    Cake actualCake = makeCake(falvor)<br>    <span class="hljs-symbol">then:</span><br>    <span class="hljs-keyword">def</span> e = thrown(IllegalArgumentException)<br>    e.message == <span class="hljs-string">&#x27;暂不支持这种口味&#x27;</span><br><br>    <span class="hljs-symbol">where:</span><br>    falovr &lt;&lt; [dog, cat]  <br>&#125;<br></code></pre></td></tr></table></figure><p>test <code>makeAndDeliverCake</code>: </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;test makeAndDeliverCake&quot;</span>() &#123;<br>    <span class="hljs-symbol">given:</span><br>    <span class="hljs-comment">// mock cakeShop &amp; prepare some data</span><br><br>    <span class="hljs-symbol">when:</span><br>    makeAndDeliverCake(apple)<br><br>    <span class="hljs-symbol">then:</span><br>    <span class="hljs-keyword">new</span> PollingConditions().within(<span class="hljs-number">20</span>, &#123; cakeShop.reveive(appCake)&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>单元测试里进行复杂的用例测试;<br>集成测试只做简单的”连通性”测试</p><ol><li><code>CakeDistributionTest</code>: only test <code>makeCake</code>  </li><li><code>CakeDistributionIntegrationTest</code>: test <code>makeAndDeliverCake</code></li></ol><p>如果前期就写复杂的集成测试: 违背小步走原则，测试太耗时，影响开发节奏</p><h3 id="测试即文档-1"><a href="#测试即文档-1" class="headerlink" title="测试即文档"></a>测试即文档</h3><p>测试用例的可读性!</p><p>Spock 是一款 BDD 风格的测试框架，语法简洁，借助 <a href="https://martinfowler.com/bliki/GivenWhenThen.html">Given-When-Then</a> 风格的标签我们可以更清晰地定义测试代码所对应的功能代码，让我们更好地理解代码的意图：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a04d4579c0bb421da34a63743377622f~tplv-k3u1fbpfcp-zoom-1.image"></p><p>Spock 来可以通过工具将测试用例导出为报告的形式！<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87e91632cfd14474a74660e50839e0e1~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="把测试代码当成功能代码来写"><a href="#把测试代码当成功能代码来写" class="headerlink" title="把测试代码当成功能代码来写"></a>把测试代码当成功能代码来写</h3><p>测试架构的设计，提升代码的可复用性，Spring 生命周期管理等</p><ul><li>使用对象工厂等方式管理测试数据</li><li>通过工具类、基类等方式提取重复代码和重复配置</li><li>善用工具，避免重复轮子，提高代码简洁度，如 JUnit 的 <code>Rule</code>，Spring-Test 提供的各种测试注解、工具类</li></ul><hr><h2 id="测试场景及实践"><a href="#测试场景及实践" class="headerlink" title="测试场景及实践:"></a>测试场景及实践:</h2><h3 id="善用构建工具🔧"><a href="#善用构建工具🔧" class="headerlink" title="善用构建工具🔧"></a>善用构建工具🔧</h3><p>e.g. 使用 maven pom 文件中的 <code>profile</code> 标签进行多版本测试，比如我们要测试程序在不同 spring 版本下是否运行正常：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring5<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Spring-容器"><a href="#Spring-容器" class="headerlink" title="Spring 容器"></a>Spring 容器</h3><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-framework">Spring-Test 官方文档</a><br>基于 Spring 的单元&#x2F;集成测试也是个很大的话题，今天暂不展开</p><h3 id="外部系统调用"><a href="#外部系统调用" class="headerlink" title="外部系统调用"></a>外部系统调用</h3><p>DB, Redis, ZK, MQ, Http-Server, Dubbo</p><p>在测试中可以使用内存中间件，比如内存 DB (H2)，内存 Redis，内存 ZK (<code>curator-test</code>)</p><p>例如 mock 一个 http server:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WireMockTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Specification</span> &#123;<br><br>    <span class="hljs-meta">@Rule</span><br>    WireMockRule wireMockRule = <span class="hljs-keyword">new</span> WireMockRule(<span class="hljs-number">18080</span>)<br><br>    <span class="hljs-keyword">def</span> wireMock = <span class="hljs-keyword">new</span> WireMockGroovy(<span class="hljs-number">18080</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-string">&quot;WireMockRule&quot;</span>() &#123;<br>        <span class="hljs-symbol">given:</span><br>        wireMockRule.stubFor(any(urlEqualTo(<span class="hljs-string">&quot;/some/thing?k1=v1&quot;</span>))<br>                .willReturn(aResponse()<br>                        .withHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>)<br>                        .withBody(<span class="hljs-string">&quot;Hello world!&quot;</span>)));<br><br>        <span class="hljs-symbol">when:</span><br>        <span class="hljs-keyword">def</span> res = org.apache.http.client.fluent.Request.Post(<span class="hljs-string">&quot;http://localhost:18080/some/thing?k1=v1&quot;</span>)<br>                .execute().returnContent().asString()<br><br>        <span class="hljs-symbol">then:</span><br>        <span class="hljs-comment">// assert result ...</span><br>        <span class="hljs-symbol">and:</span><br>        verify(<span class="hljs-number">1</span>, postRequestedFor(urlEqualTo(<span class="hljs-string">&quot;/some/thing?k1=v1&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">// http://wiremock.org/docs/stubbing/</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-string">&quot;WireMock (mock http server) | groovy style&quot;</span>() &#123;<br>        <span class="hljs-symbol">given:</span><br>        wireMock.stub &#123;<br>            request &#123;<br>                method <span class="hljs-string">&quot;GET&quot;</span><br>                url <span class="hljs-string">&quot;/book&quot;</span><br>            &#125;<br>            response &#123;<br>                status <span class="hljs-number">200</span><br>                body <span class="hljs-string">&quot;&quot;&quot;[</span><br><span class="hljs-string">                      &#123;&quot;title&quot;: &quot;Book 1&quot;, &quot;isbn&quot;: &quot;4711&quot;&#125;,</span><br><span class="hljs-string">                      &#123;&quot;title&quot;: &quot;Book 2&quot;, &quot;isbn&quot;: &quot;4712&quot;&#125;</span><br><span class="hljs-string">                    ]</span><br><span class="hljs-string">                 &quot;&quot;&quot;</span><br>                headers &#123; <span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-string">&quot;application/json&quot;</span> &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-symbol">when:</span> <span class="hljs-string">&quot;we invoke the REST client to find all books&quot;</span><br>        <span class="hljs-keyword">def</span> res = request()<br><br>        <span class="hljs-symbol">then:</span> <span class="hljs-string">&quot;we expect two books to be found&quot;</span><br>        <span class="hljs-comment">// assert result ....</span><br>        <span class="hljs-symbol">and:</span> <span class="hljs-string">&quot;the mock to be invoked exactly once&quot;</span><br>        <span class="hljs-number">1</span> == wireMock.count &#123;<br>            method <span class="hljs-string">&quot;GET&quot;</span><br>            url <span class="hljs-string">&quot;/book&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异步场景"><a href="#异步场景" class="headerlink" title="异步场景"></a>异步场景</h3><ul><li>Java: <a href="https://github.com/awaitility/awaitility">Awaitility</a></li><li>Spock: <code>PollingConditions</code>, <code>AsyncConditions</code></li></ul><h3 id="Interaction"><a href="#Interaction" class="headerlink" title="Interaction"></a>Interaction</h3><p><strong>interaction_based_testing</strong> —— 基于交互行为的测试</p><p>assert 对象的某个方法是否被调用过</p><p>实现方式：</p><ul><li><p>Mock 实例方法，比如 Java 的 <code>Mockito</code>, Spock 自带的 Mock API 等</p><ul><li>理解 Mock &amp; Stub &amp; Spy 这三者的定义和区别  <a href="http://spockframework.org/spock/docs/1.2/all_in_one.html#_interaction_based_testing">spock-doc_interaction_based_testing</a></li></ul></li><li><p>Mock 静态方法: 目前只有 <code>PowerMock</code> 支持</p></li><li><p>JUnit Rule <code>SystemOutRule</code>，通过断言控制台日志的方式来判断某个方法是否被调用过，不是很优雅，适合测试旧代码或者实在很难测试的场景</p></li><li><p>或者自己实现</p></li></ul><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p><a href="https://docs.qameta.io/allure/#_flaky_tests">flaky-test</a></p><ul><li>被测试的事件不稳定, 有一定概率失败</li><li>单独运行时正常，一起运行时失败，需要做好对象的清理工作</li></ul><hr><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具:"></a>测试工具:</h2><h3 id="测试框架："><a href="#测试框架：" class="headerlink" title="测试框架："></a>测试框架：</h3><ul><li><a href="http://spockframework.org/spock/docs/1.2/all_in_one.html#_spock_primer">Spock</a></li><li><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions">JUnit 5</a>，不推荐 <code>JUnit4</code></li></ul><p>工具目的：提升写测试的效率；让测试代码可读性更强    </p><h3 id="测试执行报告"><a href="#测试执行报告" class="headerlink" title="测试执行报告:"></a>测试执行报告:</h3><p>推荐一款工具 —— <a href="http://allure.qatools.ru/">Allure</a></p><p>maven 原生的命令行输出不好阅读:<br><img src="https://user-gold-cdn.xitu.io/2019/10/25/16e00748a5dad9e7?w=2848&h=1606&f=png&s=451667" alt="命令行输出的测试结果不好阅读"></p><p>Allure 提供了 maven 插件的形式，运行 <code>mvn allure:server</code> 命令，可以在本地生成网页，展示测试报告，测试用例的执行结果更清晰、直观：<br><img src="https://user-gold-cdn.xitu.io/2019/10/25/16e00756799f986f?w=2878&h=1544&f=png&s=644674" alt="Allure 展示执行结果"></p><p>Allure 还可以和 Jenkins 集成，查看测试执行结果的趋势变化，更好地支持持续集成：</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/25/16e0076c87e80345?w=2878&h=1558&f=png&s=225975" alt="Allure 展示测试用例耗时"></p>]]></content>
    
    
    <categories>
      
      <category>TDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Spock Tutorial for Java Developers</title>
    <link href="/2019/01/28/Spock-Tutorial-for-Javaer/"/>
    <url>/2019/01/28/Spock-Tutorial-for-Javaer/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Spock-Tutorial-for-Java-Developers"><a href="#A-Spock-Tutorial-for-Java-Developers" class="headerlink" title="A Spock Tutorial for Java Developers"></a>A Spock Tutorial for Java Developers</h1><h3 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h3><p><a href="https://github.com/spockframework/spock"></a></p><p>The description of <a href="https://github.com/spockframework/spock">its github repository</a>:</p><blockquote><p>The Enterprise-ready testing and specification framework.</p></blockquote><br><p>A Quote from the <a href="https://spockframework.org/">office website</a>:</p><blockquote><p>Spock is a testing and specification framework for Java and Groovy applications.</p><p>What makes it stand out from the crowd is its beautiful and highly expressive specification language.</p><p>Thanks to its JUnit runner, Spock is compatible with most IDEs, build tools, and continuous integration servers.</p><p>Spock is inspired from JUnit, RSpec, jMock, Mockito, Groovy, Scala, Vulcans, and other fascinating life forms.</p></blockquote><br><p><a href="https://spockframework.org/spock/docs/1.2/all_in_one.html">Spock Framework Reference Documentation</a></p><h3 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h3><ul><li><p>Specifications as Documentation (BDD); <code>given-when-then</code> ; generating-report.</p></li><li><p>less code, more readable, some awesome feature:</p><ul><li>blocks, (no)thrown, ‘&#x3D;&#x3D;’,</li><li>where, table, database,</li><li>with, verifyAll</li><li>more fluent Mock syntax</li></ul></li><li><p>support <code>JUnit</code>, it’s suppot all <code>@Rule</code>s in JUnit.</p></li></ul><h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h3><ul><li>JUnit, testNG</li><li>Cucumber(Gherkin). <strong>“one file solution”</strong></li><li>Java BDD framework, like: <a href="https://jbehave.org/">JBehave</a></li><li>RSpec <a href="https://github.com/spockframework/spock/issues/106">spock&#x2F;issues&#x2F;106</a></li></ul><h3 id="Spock-Quick-Start"><a href="#Spock-Quick-Start" class="headerlink" title="Spock Quick Start"></a>Spock Quick Start</h3><p>pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- spock --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apche.groovy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>groovy-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.spockframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spock-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4-M4-groovy-4.00<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.spockframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spock-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4-M4-groovy-4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.athaydes<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spock-reports<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.1-groovy-4.01<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.gmavenplus<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmavenplus-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>&gt;3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compileTests<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*Test.java<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*Spec.java<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Usage-Example"><a href="#Usage-Example" class="headerlink" title="Usage Example"></a>Usage Example</h3><p><a href="https://spockframework.org/spock/docs/1.2/all_in_one.html#_comparison_to_junit">Comparison to JUnit</a></p><h4 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h4><p><img src="https://spockframework.org/spock/docs/1.2/images/Blocks2Phases.png" alt="Blocks"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;events are published to all subscribers&quot;</span>() &#123;<br>  <span class="hljs-symbol">given:</span><br>  <span class="hljs-keyword">def</span> subscriber1 = Mock(Subscriber)<br>  <span class="hljs-keyword">def</span> subscriber2 = Mock(Subscriber)<br>  <span class="hljs-keyword">def</span> publisher = <span class="hljs-keyword">new</span> Publisher()<br>  publisher.add(subscriber1)<br>  publisher.add(subscriber2)<br><br>  <span class="hljs-symbol">when:</span><br>  publisher.fire(<span class="hljs-string">&quot;event&quot;</span>)<br><br>  <span class="hljs-symbol">then:</span><br>  <span class="hljs-number">1</span> * subscriber1.receive(<span class="hljs-string">&quot;event&quot;</span>)<br>  <span class="hljs-number">1</span> * subscriber2.receive(<span class="hljs-string">&quot;event&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h4><p>Within the <code>then</code> and <code>expect</code> blocks, assertions are implicit</p><h4 id="some-Shorthand-syntactic-sugar-in-Groovy"><a href="#some-Shorthand-syntactic-sugar-in-Groovy" class="headerlink" title="some Shorthand (syntactic sugar in Groovy)"></a>some Shorthand (syntactic sugar in Groovy)</h4><p> The test code wrote by Spock are more concise and easier to read.<br> There’s less clutter, boilerplate code, and your test cases can be structured better.</p><p>e.g:</p><blockquote><p>Java’s &#x3D;&#x3D; is actually Groovy’s is() method, and Groovy’s &#x3D;&#x3D; is a clever equals()!</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">str == <span class="hljs-string">&quot;content&quot;</span>     <span class="hljs-comment">// assert the equality between strings</span><br>list == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-comment">// assert the equality between lists</span><br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">publisher.subscribers &lt;&lt; subscriber <span class="hljs-comment">// &lt;&lt; is a Groovy shorthand for List.add()</span><br>publisher.subscribers - subscriber <span class="hljs-comment">// to remove element from List</span><br></code></pre></td></tr></table></figure><p>see also:<br><a href="https://groovy-lang.org/syntax.html">groovy-lang.org&#x2F;syntax.html</a><br><a href="https://learnxinyminutes.com/docs/groovy/">some demos</a></p><h4 id="Exception-Conditions"><a href="#Exception-Conditions" class="headerlink" title="Exception Conditions"></a>Exception Conditions</h4><p><code>thrown, notThrown</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">when:</span><br>stack.pop()<br><br><span class="hljs-attr">then:</span><br>thrown(EmptyStackException)<br>stack.empty<br></code></pre></td></tr></table></figure><h4 id="Support-Java-Testing-Lib"><a href="#Support-Java-Testing-Lib" class="headerlink" title="Support Java Testing Lib"></a>Support Java Testing Lib</h4><p>including JUnit, Mockito, JAssert, Hamcrest, etc.</p><h4 id="Data-Tables"><a href="#Data-Tables" class="headerlink" title="Data Tables"></a>Data Tables</h4><p>A awesome feature!</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Specification</span> &#123;<br>  <span class="hljs-keyword">def</span> <span class="hljs-string">&quot;maximum of two numbers&quot;</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) &#123;<br>    <span class="hljs-symbol">expect:</span><br>    Math.max(a, b) == c<br><br>    <span class="hljs-symbol">where:</span><br>    a | b | c<br>    <span class="hljs-number">1</span> | <span class="hljs-number">3</span> | <span class="hljs-number">3</span><br>    <span class="hljs-number">7</span> | <span class="hljs-number">4</span> | <span class="hljs-number">7</span><br>    <span class="hljs-number">0</span> | <span class="hljs-number">0</span> | <span class="hljs-number">0</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Data-Pipes"><a href="#Data-Pipes" class="headerlink" title="Data Pipes"></a>Data Pipes</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">...<br><span class="hljs-attr">where:</span><br>a &lt;&lt; [<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>]<br>b &lt;&lt; [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>c &lt;&lt; [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><hr><h3 id="Migration-from-Java-to-Groovy"><a href="#Migration-from-Java-to-Groovy" class="headerlink" title="Migration from Java to Groovy"></a>Migration from Java to Groovy</h3><h4 id="java-lambda-expression-vs-groovy-closure"><a href="#java-lambda-expression-vs-groovy-closure" class="headerlink" title="java lambda expression vs groovy closure"></a>java lambda expression vs groovy closure</h4><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">() <br>e.g: Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(i -&gt; i * <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>groovy:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">&#123;&#125;<br>e.<span class="hljs-attr">g:</span> Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map &#123; i -&gt; i * <span class="hljs-number">2</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="vs"><a href="#vs" class="headerlink" title="[] vs {}"></a>[] vs {}</h4><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ContextConfiguration(classes = &#123;A.class, B.class&#125;)</span><br></code></pre></td></tr></table></figure><p>groovy:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@ContextConfiguration</span>(classes = [A.<span class="hljs-keyword">class</span>, B.<span class="hljs-keyword">class</span>])<br><span class="hljs-meta">@ContextConfiguration</span>(classes = [A, B]) <span class="hljs-comment">// the &#x27;.class&#x27; suffix can also be ignored</span><br>String[] arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="groovy-handy-no-setter-or-no-getter-syntax"><a href="#groovy-handy-no-setter-or-no-getter-syntax" class="headerlink" title="groovy handy no-setter (or no-getter) syntax"></a>groovy handy no-setter (or no-getter) syntax</h4><p>declare a field without access modifier</p><h4 id="Precaution"><a href="#Precaution" class="headerlink" title="Precaution"></a>Precaution</h4><ul><li>IntelliJ-IDEA: must set test directory otherwise it reports <code>Empty Test Suite</code> error.</li></ul><br><ul><li>JUnit <code>@ClassRule</code><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// it works:</span><br><span class="hljs-meta">@ClassRule</span><br><span class="hljs-meta">@Shared</span><br><span class="hljs-keyword">public</span> MyRule rule = <span class="hljs-keyword">new</span> MyRule()<br><br><span class="hljs-comment">// doesn&#x27;t work (with static modifier):</span><br><span class="hljs-meta">@ClassRule</span><br><span class="hljs-meta">@Shared</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyRule rule = <span class="hljs-keyword">new</span> MyRule()<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>TDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 原理分析</title>
    <link href="/2018/11/30/spring-boot-principel/"/>
    <url>/2018/11/30/spring-boot-principel/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot-简介"><a href="#SpringBoot-简介" class="headerlink" title="SpringBoot 简介"></a>SpringBoot 简介</h2><ul><li><p>约定大于配置, 开箱即用, 最小化配置（包括 maven&#x2F;gradle 和代码里配置）</p></li><li><p>快速搭建服务，如微服务实战</p></li></ul><h2 id="SpringBoot-特性"><a href="#SpringBoot-特性" class="headerlink" title="SpringBoot 特性"></a>SpringBoot 特性</h2><ul><li><p>内嵌servlet容器: jar包启动</p><ul><li>命令行参数</li></ul></li><li><p>简化构建工具的使用，如 maven</p><ul><li>依赖管理 <code>parent pom &quot;dependencyManagement&quot;</code></li></ul></li><li><p>AutoConfiguration，提供各种 starter</p></li><li><p><code>@ConfigurationProperties</code></p></li><li><p>logging: 默认输出到控制台，简化日志配置，可以直接在 <code>application.properties</code> 文件里配置日志</p><ul><li>log pattern, color output (if terminal support ANSI)</li></ul></li><li><p>Actuator (devOps)</p><ul><li>many endpoints: <code>info, health, metrics, configprops, beans, logs ...</code></li><li>custom health indicator</li><li>结合 maven git-commit-id plugin</li></ul></li><li><p>spring-boot-devtools 热部署工具</p></li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="1-简化构建工具的使用-以-maven-为例"><a href="#1-简化构建工具的使用-以-maven-为例" class="headerlink" title="1. 简化构建工具的使用 (以 maven 为例)"></a>1. 简化构建工具的使用 (以 maven 为例)</h3><ul><li><strong>spring-boot-dependencies:</strong><ul><li>声明所有 dependency 和 plugin 的版本: 包括各种第三方类库和 starter 的版本</li></ul></li></ul><p><img src="/2020-07-28-19-57-17.png"></p><ul><li><strong>spring-boot-starter-parent:</strong><ul><li>common properties;</li><li>resource filtering: <a href="https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html">maven-resources-plugin</a></li><li>plugin configuration</li></ul></li></ul><p><img src="/2020-07-28-19-53-27.png"></p><hr><h3 id="2-自动配置原理分析"><a href="#2-自动配置原理分析" class="headerlink" title="2. 自动配置原理分析"></a>2. 自动配置原理分析</h3><h4 id="2-1-现象"><a href="#2-1-现象" class="headerlink" title="2.1 现象"></a>2.1 现象</h4><ul><li><p>添加<code>@EnableAutoConfiguration</code>注解;</p></li><li><p>在pom.xml中引入相应的starter;</p></li><li><p>(可选) 在配置文件里添加对应的配置项;</p></li><li><p>(可选) 自定义Bean，替换预定义对默认Bean;</p></li></ul><hr><h4 id="2-2-AutoConfiguration"><a href="#2-2-AutoConfiguration" class="headerlink" title="2.2 AutoConfiguration"></a>2.2 AutoConfiguration</h4><p>“xxAutoConfiguration”本质就是一个<code>@Configuration</code>类, 特殊之处在于：</p><ol><li><p>使用一系列条件化注解进行<strong>推断</strong>：是否加载当前Configuration；是否加载某个Bean.<br> 对比”手动配置”：预先定义好许多configuration和bean，通过条件触发.<br> e.g.: <code>WebMvcAutoConfiguration</code>, <code>DataSourceAutoConfiguration</code>, <code>MybatisAutoConfiguration</code></p></li><li><p>加载时机：最后加载，<strong>优先级</strong>用户定义的Bean;</p></li><li><p><code>@AutoConfigureOrder</code>注解</p></li></ol><p>如果这些注解都去掉, 就和我们在Spring应用中自定义的Configuration类没有区别了。</p><p><strong>三个问题</strong>:</p><ul><li><p>条件化触发是如何实现的？</p></li><li><p>为什么只是在 pom 里声明一个 starter, SpringBoot 就会进行对应的自动配置?<br>AutoConfiguration具体是如何被框架调用的?</p></li><li><p>为什么自定义的bean可以覆盖默认的bean?</p></li></ul><h4 id="2-3-条件化注解"><a href="#2-3-条件化注解" class="headerlink" title="2.3 条件化注解"></a>2.3 条件化注解</h4><blockquote><p>条件化加载是在Spring4中引入的新特性</p></blockquote><ul><li><p>@ConditionalOnWebApplication</p></li><li><p>@ConditionalOnMissingBean</p></li><li><p>@ConditionalOnClass</p></li><li><p>@ConditionalOnProperty</p><ul><li>havingValue</li><li>matchIfMissing</li></ul></li></ul><h5 id="自定义条件化注解"><a href="#自定义条件化注解" class="headerlink" title="自定义条件化注解:"></a>自定义条件化注解:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Conditional(xxCondition.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ConditionalOnXXX &#123;<br>&#125;<br><br><span class="hljs-comment">// xxCondition extends SpringBootCondition extends Condition</span><br></code></pre></td></tr></table></figure><h5 id="SpringBootCondition"><a href="#SpringBootCondition" class="headerlink" title="SpringBootCondition"></a>SpringBootCondition</h5><blockquote><p>Provides sensible logging to help the user diagnose what classes are loaded.</p></blockquote><ol><li><p>提供了基本的实现(template method design pattern), 子类只需要实现’getMatchOutcome’方法<br> <code> public abstract ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata);</code></p></li><li><p>提供两个子类可能用到的方法 – anyMatches, matchers<br> e.g.: EmbeddedDatabaseCondition</p></li></ol><h4 id="2-4-自动配置日志报告"><a href="#2-4-自动配置日志报告" class="headerlink" title="2.4 自动配置日志报告"></a>2.4 自动配置日志报告</h4><h5 id="生成内容"><a href="#生成内容" class="headerlink" title="生成内容"></a>生成内容</h5><p>SpringBootCondition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordEvaluation</span><span class="hljs-params">(ConditionContext context, String classOrMethodName, ConditionOutcome outcome)</span> &#123;<br>    <span class="hljs-keyword">if</span> (context.getBeanFactory() != <span class="hljs-literal">null</span>) &#123;<br>        ConditionEvaluationReport.get(context.getBeanFactory())<br>                .recordConditionEvaluation(classOrMethodName, <span class="hljs-built_in">this</span>, outcome);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>core classes of ‘conditional evaluation reporting’: <code>ConditionMessage</code>, <code>ConditionOutcome</code>, <code>ConditionEvaluationReport</code>.</p><h5 id="输出内容"><a href="#输出内容" class="headerlink" title="输出内容"></a>输出内容</h5><p>ConditionEvaluationReportLoggingListener.ConditionEvaluationReportListener<br>监听<code>ContextRefreshedEvent</code>和<code>ApplicationFailedEvent</code>这两个事件, 输出自动报告的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAutoConfigurationReport</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isCrashReport)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.report == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.applicationContext == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.logger.info(<span class="hljs-string">&quot;Unable to provide the conditions report &quot;</span><br>                    + <span class="hljs-string">&quot;due to missing ApplicationContext&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.report = ConditionEvaluationReport<br>                .get(<span class="hljs-built_in">this</span>.applicationContext.getBeanFactory());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.report.getConditionAndOutcomesBySource().isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (isCrashReport &amp;&amp; <span class="hljs-built_in">this</span>.logger.isInfoEnabled()<br>                &amp;&amp; !<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.info(String<br>                    .format(<span class="hljs-string">&quot;%n%nError starting ApplicationContext. To display the &quot;</span><br>                            + <span class="hljs-string">&quot;conditions report re-run your application with &quot;</span><br>                            + <span class="hljs-string">&quot;&#x27;debug&#x27; enabled.&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionEvaluationReportMessage</span>(<span class="hljs-built_in">this</span>.report));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConditionEvaluationReportMessage.toString()</code>输出的内容就是我们在控制台看到的自动配置报告了。</p><hr><h4 id="2-5-AutoConfiguration加载原理"><a href="#2-5-AutoConfiguration加载原理" class="headerlink" title="2.5 AutoConfiguration加载原理"></a>2.5 AutoConfiguration加载原理</h4><h5 id="SpringFactoriesLoader-since-3-2"><a href="#SpringFactoriesLoader-since-3-2" class="headerlink" title="SpringFactoriesLoader (since 3.2)"></a>SpringFactoriesLoader (since 3.2)</h5><p>java doc:</p><blockquote><p>General purpose factory loading mechanism for internal use within the framework.<br>SpringFactoriesLoader loads and instantiates factories of a given type from “META-INF&#x2F;spring.factories” files<br>which may be present in multiple JAR files in the classpath.<br>The spring.factories file must be in Properties format, where the key is the fully qualified name of the interface or abstract class,<br>and the value is a comma-separated list of implementation class names.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span><br></code></pre></td></tr></table></figure><p>之所以把这个放在前面介绍是因为SpringBoot里大量地使用里这个机制，加载AutoConfiguration只是其中的一个运用, 后面会提到其他的使用场景。</p><p>通过<code>SpringFactoriesLoader</code>寻找类路径下的所有的’META-INF&#x2F;spring.factories’文件，<br>找到所有key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>所对应的value，<br>得到一个列表：所有AutoConfiguration的全限定类名。</p><p>SpringBoot预定义的’autoconfiguration’: spring-boot-autoconfigure-xxx.jar: META-INF&#x2F;spring.factories</p><p>对于自带的AutoConfiguration和三方的AutoConfiguration, SpringBoot采取完全相同的加载方式.</p><blockquote><p>SpringFactoriesLoader的实现类似于SPI（Service Provider Interface)<br>java SPI提供一种服务发现机制，为某个接口寻找服务实现的机制。<br>有点类似IOC的思想，将装配的控制权移到程序之外.</p></blockquote><h5 id="Java-SPI-JDBC-4-0"><a href="#Java-SPI-JDBC-4-0" class="headerlink" title="Java SPI (JDBC 4.0)"></a>Java SPI (JDBC 4.0)</h5><p><code>java.util.ServiceLoader</code> <a href="https://blog.csdn.net/u013679744/article/details/80009878">SPI</a><br>before JDBC 4.0:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Register JDBC driver</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">// Open a connection</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(DB_URL, USER, PASS);<br></code></pre></td></tr></table></figure><p>JDBC 4.0:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Open a connection</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(DB_URL, USER, PASS);<br></code></pre></td></tr></table></figure><h5 id="DeferredImportSelector"><a href="#DeferredImportSelector" class="headerlink" title="DeferredImportSelector"></a>DeferredImportSelector</h5><p><code>@EnableAutoConfiguration</code>注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @Import(EnableAutoConfigurationImportSelector.class) // if the version is 1.x</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;&#125;<br></code></pre></td></tr></table></figure><p><code>AutoConfigurationImportSelector --&gt; DeferredImportSelector (since 4.0) --&gt; ImportSelector (since 3.1)</code></p><p>ImportSelector:</p><blockquote><p>Interface to be implemented by types that determine which @Configuration class(es) should be imported<br>based on a given selection criteria, usually one or more annotation attributes.</p></blockquote><p>可以理解为是动态地加载Configuration类</p><h5 id="AutoConfigurationImportSelector-selectImports"><a href="#AutoConfigurationImportSelector-selectImports" class="headerlink" title="AutoConfigurationImportSelector.selectImports:"></a>AutoConfigurationImportSelector.selectImports:</h5><ol><li><p>Find all possible auto configuration classes, filtering duplicates</p> <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">configurations</span> <span class="hljs-operator">=</span> <span class="hljs-variable">getCandidateConfigurations</span><span class="hljs-punctuation">(</span><span class="hljs-variable">annotationMetadata</span><span class="hljs-operator">,</span> <span class="hljs-variable">attributes</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure></li><li><p>Remove those specifically disabled</p><ol><li>@EnableAutoConfiguration exclude</li><li>spring.autoconfigure.exclude</li></ol></li><li><p>Check excluded classes</p></li><li><p><em>Filter auto-config</em> by <code>AutoConfigurationImportFilter</code> (spring.factories)<br> <em>拓展点</em>: 过滤掉先前的”AutoConfiguration”</p></li><li><p>fireAutoConfigurationImportEvents, <code>AutoConfigurationImportListener</code> (spring.factories)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ConditionEvaluationReportAutoConfigurationImportListener<br><br>report.recordEvaluationCandidates(event.getCandidateConfigurations());<br>report.recordExclusions(event.getExclusions());<br></code></pre></td></tr></table></figure></li></ol><h5 id="OnClassCondition-implements-AutoConfigurationImportFilter"><a href="#OnClassCondition-implements-AutoConfigurationImportFilter" class="headerlink" title="OnClassCondition (implements AutoConfigurationImportFilter)"></a>OnClassCondition (implements AutoConfigurationImportFilter)</h5><p><code>AutoConfigurationImportFilter</code>:</p><blockquote><p>Filter that can be registered in {@code spring.factories} to limit the  auto-configuration classes considered.<br>This interface is designed to allow fast removal  of auto-configuration classes before their bytecode is even read.</p></blockquote><p>spring-boot-autoconfigure-xx.jar  META-INF&#x2F;spring-autoconfigure-metadata.properties</p><p><code>AutoConfigurationMetadata</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">AutoConfigurationImportSelector.selectImports:<br>    <span class="hljs-type">AutoConfigurationMetadata</span> <span class="hljs-variable">autoConfigurationMetadata</span> <span class="hljs-operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);<br><br>OnClassCondition.StandardOutcomesResolver.getOutcomes:<br>    Set&lt;String&gt; candidates = autoConfigurationMetadata.getSet(autoConfigurationClass, <span class="hljs-string">&quot;ConditionalOnClass&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="ImportSelector是如何被Spring框架调用的"><a href="#ImportSelector是如何被Spring框架调用的" class="headerlink" title="ImportSelector是如何被Spring框架调用的"></a>ImportSelector是如何被Spring框架调用的</h5><p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors:</p><ul><li>ConfigurationClassParser.parse<ul><li>parse<ul><li>processConfigurationClass<ul><li>doProcessConfigurationClass<ul><li>processImports</li></ul></li></ul></li></ul></li><li>processDeferredImportSelectors</li></ul></li></ul><h4 id="2-6-ImportAutoConfiguration-useful-for-testing"><a href="#2-6-ImportAutoConfiguration-useful-for-testing" class="headerlink" title="2.6 @ImportAutoConfiguration (useful for testing)"></a>2.6 @ImportAutoConfiguration (useful for testing)</h4><blockquote><p>Variant of AutoConfigurationImportSelector for ImportAutoConfiguration.</p></blockquote><p>override method - <code>getCandidateConfigurations</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectAnnotations</span><span class="hljs-params">(Class&lt;?&gt; source,</span><br><span class="hljs-params">        MultiValueMap&lt;Class&lt;?&gt;, Annotation&gt; annotations, HashSet&lt;Class&lt;?&gt;&gt; seen)</span> &#123;<br>    <span class="hljs-keyword">if</span> (source != <span class="hljs-literal">null</span> &amp;&amp; seen.add(source)) &#123;<br>        <span class="hljs-keyword">for</span> (Annotation annotation : source.getDeclaredAnnotations()) &#123;<br>            <span class="hljs-keyword">if</span> (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation)) &#123;<br>                <span class="hljs-keyword">if</span> (ANNOTATION_NAMES<br>                        .contains(annotation.annotationType().getName())) &#123;<br>                    annotations.add(source, annotation);<br>                &#125;<br>                collectAnnotations(annotation.annotationType(), annotations, seen);<br>            &#125;<br>        &#125;<br>        collectAnnotations(source.getSuperclass(), annotations, seen);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Collection&lt;String&gt; <span class="hljs-title function_">getConfigurationsForAnnotation</span><span class="hljs-params">(Class&lt;?&gt; source,</span><br><span class="hljs-params">        Annotation annotation)</span> &#123;<br>    String[] classes = (String[]) AnnotationUtils<br>            .getAnnotationAttributes(annotation, <span class="hljs-literal">true</span>).get(<span class="hljs-string">&quot;classes&quot;</span>);<br>    <span class="hljs-keyword">if</span> (classes.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(classes);<br>    &#125;<br>    <span class="hljs-keyword">return</span> loadFactoryNames(source);<br>&#125;<br></code></pre></td></tr></table></figure><p>e.g.: <code>DataJpaTest</code></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/346cac67bfcc">简书-Spring Boot自动配置原理</a></p><p><a href="http://www.scienjus.com/spring-cloud-autoconfiguration/">Spring Cloud AutoConfiguration 简介</a></p><p><a href="https://www.jianshu.com/p/23d4e853b15b">详解Spring的ImportSelector接口</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇葩说第五季 17 期 “全人类大脑一秒知识共享” — 我想到的反方杀手锏</title>
    <link href="/2018/11/17/%E5%A5%87%E8%91%A9%E8%AF%B4%E7%AC%AC%E4%BA%94%E5%AD%A317%E6%9C%9F-%E6%88%91%E6%83%B3%E5%88%B0%E7%9A%84%E5%8F%8D%E6%96%B9%E6%9D%80%E6%89%8B%E9%94%8F/"/>
    <url>/2018/11/17/%E5%A5%87%E8%91%A9%E8%AF%B4%E7%AC%AC%E4%BA%94%E5%AD%A317%E6%9C%9F-%E6%88%91%E6%83%B3%E5%88%B0%E7%9A%84%E5%8F%8D%E6%96%B9%E6%9D%80%E6%89%8B%E9%94%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>辩题：奇葩星球新技术可以让全人类大脑一秒知识共享，你支持吗？</p></blockquote><iframe src="https://em.iq.com/player.html?id=19rr3q7xdg&sh_pltf=4" width="480" height="270" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true"></iframe>  <p>今天中午看完了奇葩说，感觉反方好难辩呀，除了薛教授以外很难再找到什么强有力的点。<br>和一个兄弟在电话里也讨论过，发现仔细想的话这个题目本身就是一个悖论在逻辑上是很奇怪的一件事（这个就像梁文道最后说的）。<br>晚上在回家的路上突然想到反方的一些点，其实是可以从题目本身的荒谬性入手延展出一些东西来的，一时兴起把这些想法记下来了，类似于草稿，有些细节因为打字太累就懒的写了，明白大意就好啦，下面是具体内容:   </p><h2 id="明确定义"><a href="#明确定义" class="headerlink" title="明确定义"></a>明确定义</h2><p>首先要把这里“知识”的定义讨论清楚，题目中的“知识”到底是什么，这里所指的知识肯定不是书本上的，网络上的“静态知识”，不然这个芯片就仅仅是加强版的搜索引擎，放到脑子里只是让我们搜索更方便而已。<br>如果这里知识的定义仅仅是这样的话，那我是不是可以说我虽然没有掌握全人类的知识，但是我已经掌握了高等物理学的知识，相对论的知识，因为我已经可以凭借各种手段获取到所有物理学的文献资料，所以我就获取了所有物理学的知识，只是我没有芯片需要人工查找这些知识而已。<br>是这样吗？并没有！这个说法看来很荒谬是吧？我实际上获取的只是资料，不是知识。<br>一个不会编程的人就算可以拿到全世界的编程资料，这也无法使他学会编程，因为他拥有的只是编程的资料，而不是编程的知识，即便那叫知识，那也是他人的知识结果，而非自己的知识。<br>所以芯片给我们带来的不是全世界的资料，而是知识，我们加一个限定词，它是一种习得的知识，一种芯片持有人自己拥有的知识。<br>不仅仅是我脑海中有无数个方程式而是我真正理解了这些方程式。<br>我们先对知识的定义达成共识，把这个拎清楚非常重要！<br>节目里正方双方一直似乎没有尝试过拎清这个定义，而这个定义正是下面我的所有论点的前提条件。</p><h2 id="改变人格"><a href="#改变人格" class="headerlink" title="改变人格"></a>改变人格</h2><p>所以，翻译一下，题目表达的意思是：全人类一瞬间获取掌握所有知识，如果知道目前我们人类仅仅是学习一门知识就需要耗费我们一个辈子甚至是几辈子的时间，举例……（balabala）<br>知识对于人格的塑造 —&gt; 拥有芯片会改变人格 （……简单论证下），不仅仅是更博学这么简单。</p><p>在一个人没有同意的前提下，我们有权利按照自己的意愿直接在他脸上动刀子，给他做整容手术吗？<br>这显然是一种侵犯对吧？违背了他的自由意志是吧？<br>但是换成我私自给全世界人的人格动手术，怎么就变成理所当然了呢？</p><h2 id="诅咒"><a href="#诅咒" class="headerlink" title="诅咒"></a>诅咒</h2><p>拥有所有知识，在我看来是不可想象的，就好像是获得全知之眼，就在我看来已经不是人了，而是接近神的存在，也许这就是新世界的神吧。<br>作为新世界的神我们无法像真正的神一样全知全能，但至少我们可以做到<strong>全知</strong>，神可以看见世界的全貌，人世间的每一个角落，而“新世界的神”可以触探到所有的知识边界，明白每一个知识的细节。<br>全知的代价：看到太多我们不想看到的细节，甚至是黑暗的东西 （……balabala）  </p><p>中学老师例子（在每年学校组织参观大屠杀遇难同胞纪念馆的时候，她会找一些理由请假不去….. 她说我们有义务了解历史，但是我身为一个个体我也有回避残忍的权利）。。。。。。<br>历史上有多少和大屠杀一样黑暗甚至更黑暗的东西，可这些在历史上都发生过，这些都是实实在在的历史知识，不是所有人都用勇气掌握这些知识的！<br>（历史学只是我目前想到一个例子，也可以据其他领域的例子，用来论证不是所有人都想掌握某个领域的知识）   </p><p>这边举这个例子不是对历史学家有什么偏见，而是想说明每个人的性格特质都是不同的，有些东西不适合他，他会承受不了，好比有人晕血害怕尸体，所以不去学医，而现在你们强行赋予了他所有医学领域的知识，这对他的心灵可能是一种负担。<br>他曾经恐惧过逃避过的东西，现在事无巨细的呈现在他的眼前，挥之不去。</p><p><strong>强行给人们装上全知之眼，对很多人而言不是祝福而是诅咒！</strong><br>还想到一个例子，是一篇科幻小说，讲的是如果人类的记忆可以延续，婴儿可以获取父辈祖辈的记忆…… 结果是婴儿直接在母胎里自杀了，因为看到了身而为人太多的痛苦，所以完全失去了降临人世的勇气。</p><p>没有正方（陈铭）描绘的那么美好: 我拥有了所有的大门，我可以选择开启任意一扇大门，去探索一个全新的世界。<br>全知的代价是对于你而言这个世界上已经没有什么紧闭的大门了，你对门里发生的事情一清二楚，了解所有的状况，也包括自己不愿意了解的，自己无法承受的东西，一下子一瞬间都汇入你的脑海，这是你生命不可承受之重。</p><p>天堂：我可以获取全人类智慧的结晶<br>地狱：我了解到太多丑陋黑暗畸形痛苦扭曲的东西，背负全人类的罪恶感。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到题目，它说的是：按下一个按钮，让<strong>所有</strong>人掌握<strong>所有</strong>知识，题目不是让某个人自由选择自己是否可以掌握某些领域的知识，其实这个已经出现在刘慈欣的短片小说《朝闻道》里了 （……. 略去介绍）。</p><p>和我们目前接触到的所有技术都不同，这项技术会让全人类都脱胎换骨，拥有所有知识之后全人类到底是会变的一样还是每个人都不一样，我不知道，就像我不知道宇宙的边界，是什么以及宇宙是否有边界，但是我所能预见到就是人类将不再是人类了，而是会进化成为一种新的生命体，这种生命体在我们这些旧人类看来很接近神。<br>问题是不是所有人都想成为新世界的神，你凭什么为所有人做决定？</p><p>植入芯片会让我们变得面目全非，刚才论证了拥有“全知”这种能力对很多人来说是一件很痛苦的事，是一种诅咒。<br>拥有“全知”的能力对有些人来说可能是一种无间地狱，你按下一个按钮，把一个人推入地狱，这是谁给你的权利？</p><p>关键字：改变人格&#x2F;思想；黑暗面；自由意志  </p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>自我感觉这几个点还是蛮有力的，欢迎讨论拍砖。</p>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成为 1.1 倍程序员 - 实用效能工具分享</title>
    <link href="/2018/10/21/productivity-tools-sharing/"/>
    <url>/2018/10/21/productivity-tools-sharing/</url>
    
    <content type="html"><![CDATA[<blockquote><p>10 倍程序员一直是一个经久不衰的话题，然而 10 倍程序员对于很多人来说是一个遥不可及的目标，不过我们可以通过各种实用工具🔧提高自己的生产效率，先让自己成为一个 1.1 倍程序员。</p><p>乘以十太困难了, 那就先加百分之十吧！</p><p>下面分享几款我日常使用的实用工具, 因为本人 win 和 mac 都用过，所以对于同一类型的功能需求我会对两种平台下的工具都做一下介绍。</p></blockquote><h2 id="文件快速搜索"><a href="#文件快速搜索" class="headerlink" title="文件快速搜索"></a>文件快速搜索</h2><h3 id="Listary-win"><a href="#Listary-win" class="headerlink" title="Listary (win)"></a>Listary (win)</h3><p>和everything相比, 提供可视化界面, 全局快捷键呼出应用，必不可少的一款应用</p><h3 id="Alfred-mac"><a href="#Alfred-mac" class="headerlink" title="Alfred (mac)"></a>Alfred (mac)</h3><p>功能丰富，除了文件搜索功能，还提供了其他功能，如:</p><ul><li>snippets: 一键呼出常用文本</li><li>clipboard: mac下无需再去寻找其他剪切板加强工具，一款Alfred就足够了</li></ul><p>这两款都是提高工具效率的利器</p><h3 id="autojump-cmd"><a href="#autojump-cmd" class="headerlink" title="autojump (cmd)"></a>autojump (cmd)</h3><p>非常好用的一款 Unix 命令行工具, 快速跳转到目录, 使用Mac时我极少使用Finder，而是通过命令行访问目录，操作文件, 这样更高效。<br>可以使用很多命令行工具，这也是 Mac-OS 优于 Win 的地方。<br><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f0822378d6487d?w=2846&h=304&f=png&s=193291"></p><h2 id="剪切板历史"><a href="#剪切板历史" class="headerlink" title="剪切板历史"></a>剪切板历史</h2><blockquote><p>为了复制粘贴几段信息，来回切换窗口？<br>已经复制过的信息，还要跑到原始窗口再复制一遍?<br>连手机(比如锤子)都支持”剪切板历史”这一功能了，你还在用这么低效的方式办公？</p><p>尤其是面对运维性质比较浓的一些工作，这款工具可以分享明显地提高效率。</p></blockquote><h3 id="Ditto-win"><a href="#Ditto-win" class="headerlink" title="Ditto (win)"></a>Ditto (win)</h3><h3 id="Alfred-clipboard-mac"><a href="#Alfred-clipboard-mac" class="headerlink" title="Alfred-clipboard (mac)"></a>Alfred-clipboard (mac)</h3><p>显示所有剪切板📋历史，甚至可以预览之前复制过的图片<br><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f082b6e3c71436?w=1156&h=852&f=png&s=970561"></p><h2 id="键位映射-修改"><a href="#键位映射-修改" class="headerlink" title="键位映射&#x2F;修改"></a>键位映射&#x2F;修改</h2><p>系统原生的键位总是那么不尽如人意，比如: </p><ul><li>默认的输入法方式; </li><li>MacBook反人类的<code>fn</code>键的位置; </li><li>mac外接键盘时<code>command</code>键的位置很尴尬;</li></ul><p>一些需求：</p><ul><li>一键切换指定输入法</li><li>方向键映射（不用让手离开主键盘移动到右下方的方向键然后再回来，节省零点几秒）</li></ul><p><strong>vimer</strong> 必备：</p><ul><li><code>esc</code>键位置太远，可以映射为<code>cap</code>键</li><li>vim 切换为”普通模式”时如何自动切换为英文输入法,<br>  解决方案：将按下<code>cap</code>键映射为：按下<code>esc</code>+ {切换到英文输入法}</li></ul><h3 id="AHK-win"><a href="#AHK-win" class="headerlink" title="AHK (win)"></a>AHK (win)</h3><h3 id="Karabiner-mac"><a href="#Karabiner-mac" class="headerlink" title="Karabiner (mac)"></a>Karabiner (mac)</h3><p>TODO: 具体配置之后再分享</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f0816818b7bd9c?w=2000&h=1144&f=png&s=234692"></p><h2 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h2><h3 id="Contexts-mac"><a href="#Contexts-mac" class="headerlink" title="Contexts (mac)"></a>Contexts (mac)</h3><p>mac原生的窗口切换方式有点反人类, 竟然不支持同一个应用内多个窗口的情况! 比如我IDEA开多个工程时，用原生的切换方式会很麻烦。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f080cea44a1121?w=1914&h=882&f=png&s=336556"></p><h2 id="网盘下载"><a href="#网盘下载" class="headerlink" title="网盘下载"></a>网盘下载</h2><h3 id="panDownload-win"><a href="#panDownload-win" class="headerlink" title="panDownload (win)"></a>panDownload (win)</h3><p>亲测可用</p><h3 id="Aria2-mac-chrome插件-Exporter"><a href="#Aria2-mac-chrome插件-Exporter" class="headerlink" title="Aria2 (mac) + chrome插件 Exporter"></a>Aria2 (mac) + chrome插件 Exporter</h3><h2 id="鼠标手势"><a href="#鼠标手势" class="headerlink" title="鼠标手势"></a>鼠标手势</h2><h3 id="WGesture-win"><a href="#WGesture-win" class="headerlink" title="WGesture (win)"></a>WGesture (win)</h3><p>全局鼠标手势工具, Chrome浏览器也有鼠标手势插件, 但是有了这个全局的工具, 就可以取代它了。 </p><h2 id="RunAsDate-win"><a href="#RunAsDate-win" class="headerlink" title="RunAsDate (win)"></a>RunAsDate (win)</h2><p>破解软件时可以用，通过这个命令行工具启动目标软件，这个软件拿到的是假的系统时间，可以实现无限试用。</p><h2 id="TripMode-win-mac"><a href="#TripMode-win-mac" class="headerlink" title="TripMode (win &amp; mac)"></a>TripMode (win &amp; mac)</h2><p>所有应用的网络访问控制开关，我在用手机热点时，会开这个软件，只让部分应用可以使用网络，防止有些应用在后台消耗过多流量。<br>mac下需要收费</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f080b45de48a34?w=642&h=798&f=png&s=557709"></p><h2 id="在线代码浏览"><a href="#在线代码浏览" class="headerlink" title="在线代码浏览"></a>在线代码浏览</h2><h3 id="sourcegraph"><a href="#sourcegraph" class="headerlink" title="sourcegraph"></a>sourcegraph</h3><p>快速搜索、浏览代码，功能强大。<br><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f08116e16066f8?w=2878&h=1610&f=png&s=705119"></p><h3 id="gitpod"><a href="#gitpod" class="headerlink" title="gitpod"></a>gitpod</h3><p>实际上就是一个在线版的 vs-code，可以在线编程， 支持代码跳转，依赖解析，命令行运行等功能，有了它在网吧编程不是梦想～</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f080a56e108352?w=2868&h=1716&f=png&s=719867"></p><hr><p>以上是我平时用的各种工具，欢迎大家交流分享～</p>]]></content>
    
    
    <categories>
      
      <category>Productivity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Productivity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Integer 的自动装箱和缓存机制 — 一道面试题引出的有趣问题</title>
    <link href="/2018/06/26/Java-Integer%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2018/06/26/Java-Integer%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近遇到一道Java面试题, 感觉很有意思, 和大家分享一下.<br>是远程在线做题的, 可以使用自己的IDE. </p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params">Integer a, Integer b</span>)</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>    Integer a = <span class="hljs-number">1</span>;<br>    Integer b = <span class="hljs-number">2</span>;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;before:a=&quot;</span> + a + <span class="hljs-string">&quot;,b=&quot;</span> + b);<br>    swap(a, b);<span class="hljs-comment">//实现此swap函数；交换位置</span><br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;after:a=&quot;</span> + a + <span class="hljs-string">&quot;,b=&quot;</span> + b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实际过程中-错误的-解法"><a href="#实际过程中-错误的-解法" class="headerlink" title="实际过程中(错误的)解法"></a>实际过程中(错误的)解法</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h4><p>第一感觉还是比较简单的, 由于Integer是不可变对象, 所以利用反射修改他们内部维护的那个’value’字段. </p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下:"></a>代码如下:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">valueA</span> <span class="hljs-operator">=</span> b;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">valueB</span> <span class="hljs-operator">=</span> a;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">innerFieldName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;value&quot;</span>;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Integer.class.getDeclaredField(innerFieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br><br>        modifyViaReflection(a, valueA, field);<br>        modifyViaReflection(b, valueB, field);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyViaReflection</span><span class="hljs-params">(Integer obj, <span class="hljs-type">int</span> val, Field field)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>    field.set(obj, val);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行结果-a可以修改成功而b不可以"><a href="#运行结果-a可以修改成功而b不可以" class="headerlink" title="运行结果: a可以修改成功而b不可以."></a>运行结果: a可以修改成功而b不可以.</h4><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>当发现下面的调试输出结果时我是有点崩溃的:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 传入的val为1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyViaReflection</span>(Integer obj, <span class="hljs-type">int</span> val, Field field) <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;before obj = &#123;&#125;&quot;</span>, obj); <span class="hljs-comment">// print 2</span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;val = &quot;</span> + val); <span class="hljs-comment">// print 1</span><br>    field.<span class="hljs-property">set</span>(obj, val);<br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;after obj = &#123;&#125;&quot;</span>, obj); <span class="hljs-comment">// print 2 !!! (使用反射修改字段值失败)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当时调了好久, 明明传入的val是1, 为什么会修改不成功呢?</p><ul><li>第一次修改是成功的, 第二次就不行, 调换了a和b的次序, 同样如此;</li><li>甚至怀疑是JDK版本的原因, 还从JDK8切换到了JDK6: 无果;</li></ul><p>面试完之后, 继续探索: </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 传入的val为1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyViaReflection</span>(Integer obj, <span class="hljs-type">int</span> val, Field field) <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;before obj = &#123;&#125;&quot;</span>, obj); <span class="hljs-comment">// print 2</span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;val = &quot;</span> + val); <span class="hljs-comment">// print 1</span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;val = &#123;&#125;&quot;</span>, val); <span class="hljs-comment">// print 2 !!!  (加了这一行调试语句后后发现了新大陆)</span><br>    field.<span class="hljs-property">set</span>(obj, val);<br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;after obj = &#123;&#125;&quot;</span>, obj); <span class="hljs-comment">// print 2 !!! (使用反射修改字段值失败)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正确的解法"><a href="#正确的解法" class="headerlink" title="正确的解法"></a>正确的解法</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> modifyViaReflection(Integer obj, int <span class="hljs-keyword">val</span>, Field field) throws IllegalAccessException &#123;<br>    log.debug(<span class="hljs-string">&quot;val = &quot;</span> <span class="hljs-operator">+</span> <span class="hljs-keyword">val</span>); <span class="hljs-comment">// when val == 1, print 1</span><br>    log.debug(<span class="hljs-string">&quot;val = &#123;&#125;&quot;</span>, <span class="hljs-keyword">val</span>); <span class="hljs-comment">// when val ==1, print 2 (很奇怪吧, 看下面的解释)</span><br><br>    <span class="hljs-operator">/*</span><br>    如果按照下面那行<span class="hljs-string">&quot;错误写法&quot;</span>那样写的话, 当入参<span class="hljs-keyword">val</span>为<span class="hljs-number">1</span>时, 它会被解糖为<span class="hljs-string">&quot;Integer.value(1)&quot;</span>,<br>    由于Integer的cache机制, <span class="hljs-string">&quot;Integer.value(1)&quot;</span>和a会是同一个对象, 指向的都是<span class="hljs-string">&quot;Integer Cache&quot;</span>中的那个对象.<br>    然而这个对象的value字段已经被我们改成<span class="hljs-number">2</span>了<span class="hljs-operator">!</span><br>    所以就会出现明明传入的<span class="hljs-keyword">val</span>为<span class="hljs-number">1</span>, 但是调用完field#<span class="hljs-built_in">set</span>方法之后, obj还是<span class="hljs-number">2</span>的奇怪现象.<br>    <span class="hljs-operator">*/</span><br>    <span class="hljs-comment">// field.set(obj, val); // 错误的写法! 会被解糖为: field.set(obj, Integer.valueOf(val));</span><br>    field.<span class="hljs-built_in">set</span>(obj, <span class="hljs-keyword">new</span> Integer(<span class="hljs-keyword">val</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><ul><li>心态: 限时一小时, 总共两题, 第一题就卡主了, 有点紧张, 有点慌了. </li><li>知识储备: Integer的自动拆装箱, 前258位的缓存机制, 这些其实都懂, 但是做题的时候没有把这两个联系到一起; </li><li>调试原则: 遇到问题需要最先怀疑还是自己写的代码, 其次怀疑编译器, 操作系统, 社会环境之类的问题;<br>  比如当时应该重点关注<code>field.set(obj, val);</code>这句代码, set方法第二个参数是Object, 不是int, 是会发生自动装箱的,<br>  当时要是能意识到这个就能很快定位到问题了.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Hexo + Coding Pages 搭建个人博客</title>
    <link href="/2017/01/23/%E4%BD%BF%E7%94%A8hexo-Coding-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2017/01/23/%E4%BD%BF%E7%94%A8hexo-Coding-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话说程序员应该有一个自己的博客，我是从2016年9月——也就是四个月前开始写尝试写博客的，那时是在csdn上写的，最近接触了<strong>coding</strong>，它和github一样提供了“静态页面网站托管”的功能，觉得有搞头，这有一个好处就是相当于给了我一个免费的域名，例如我现在博客的域名就是cxfree.coding.me，乍一看还真像那么回事，来起比自己买vps，搭建维护web应用，购买域名等等之一系列操作简单多了！<br>刚好最近接触了<strong>nodejs</strong>，<strong>hexo</strong>是基于nodejs开发的，使用得挺广泛的，所以最终决定<strong>hexo+Coding Pages</strong>搭建个人博客的方案。下面介绍自己搭建过程中遇到的一些问题及解决思路。</p><h2 id="关于静态资源404的问题"><a href="#关于静态资源404的问题" class="headerlink" title="关于静态资源404的问题"></a>关于静态资源404的问题</h2><p>由于hexo生成的html引用静态资源时是以这种形式的：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;</code><br>用的是绝对路径，是相对于主机地址的，coding上是 <code>$&#123;user_name&#125;.coding.me</code><br>而我们部署的项目的地址却是<code>$&#123;user_name&#125;.coding.me/$&#123;project_name&#125;</code><br>这就很尴尬了。</p><p><strong>解决办法：</strong></p><ol><li><p>还能怎么办，修改html文件呗，批量修改静态资源标签。<br>  一种办法是等hexo生成完毕之后，用程序批量修改html文件，太麻烦了。<br>  还有一种是学习hexo的生成机制，修改其默认generate方式，让它能够生成我们预期的html文件形式，学习成本也比较高。</p></li><li><p>网上早有现成的解决办法了，把项目名改成和用户名一样就可以了。<br>为什么呢？<br>因为这是利用了coding本身的一种特性：<br>经实验发现<br><code>$&#123;user_name&#125;.coding.me</code><br>   等价于</p></li></ol><p><code>$&#123;user_name&#125;.coding.me/$&#123;user_name&#125;</code><br>所以，显然<br><code>$&#123;user_name&#125;.coding.me/css/style.css</code><br>          也等价于<br><code>$&#123;user_name&#125;.coding.me/$&#123;user_name&#125;/css/style.css</code><br>这是最简单直接的解决办法了，唯一不好的是没法像这样再搭建第二个博客（因为项目名要和用户名相同嘛），不过这些不算什么事，毕竟只是现在只是为了快速搭建，快速上手在coding上体验一下个人博客。等将来学有所成，可以更灵活地部署静态网页，或者使用Coding Pages 内定的jekyll。</p><h2 id="markdow引用的图片放在哪？"><a href="#markdow引用的图片放在哪？" class="headerlink" title="markdow引用的图片放在哪？"></a>markdow引用的图片放在哪？</h2><ol><li><p><strong>使用相对路径</strong>，也就是使用本地图片，好处是不依赖第三方服务，hexo也提供了相应的插件，允许插入本地图片，并且提供了相应的标签，可就坏在这里，这样子用md编辑器编辑时就没法看到图片了，不能做到所见即所得，比较不友好，对于这一点别人可能有解决办法吧，我还没去研究。</p></li><li><p><strong>引入远程的图片资源</strong>，使用**“图床”<strong>，把图片放在第三方公共存储服务提供商那里，例如网上推荐比较多的</strong>“七牛”<strong>，因为是国内的服务，所以不用考虑被墙的风险，使用这种方案最大的好处是markdown文件的”可移植性“非常强，因为图片是远程的，所以在任何地方打开md文件都能看到图片。我用的是</strong>马克飞象**，这样还可以把md文件（也就是博客）同步到印象笔记上，方便我使用印象笔记时随时能够查看博客文章。</p></li></ol><p>刚开始的时候犹豫采取什么方案，后来想到这个好处之后果断使用七牛来存放图片，花了两个小时，摸索了七牛的文件上传工具和它提供的api，七牛官方内定的命令行工具“<strong>qshell</strong>”，功能貌似强大的，但要想高效引用文件的话还得自己加入一些个性化需求，打算开发个命令行程序，功能是这样的：</p><blockquote><p>配置一个本地文件目录，把想要上传的文件丢到里面，程序支持“增量同步功能”，也就是说只上传新增的文件。<br>把文件丢进指定目录后，使用命令行运行指令，程序去调用qshell的命令把文件上传到七牛，然后把文件的外链写入剪切板。</p></blockquote><blockquote><p>写博客时引用图片大多是使用的截图，下面以截图然后引入图片为例，梳理一下操作步骤：<br>  第一步：使用截取软件（我用的是qq截图），图片另存为到指定目录。<br>  第二步：运行命令行程序，程序会自动把图片上传到七牛，然后把外链写入系统剪切板<br>  第三步：回到markdown编辑器（如我用的马克飞象）执行ctrl+v 就得到图片的链接了，搞定！</p></blockquote><p>现在已经把这个工具写好了，github地址：<a href="https://github.com/cxfree/qiniu-sync-tool">https://github.com/cxfree/qiniu-sync-tool</a></p><p>力求最高效地引入图片，提高写作效率。如何大家还有更好的方法欢迎交流。</p><p>想要注册七牛云的可以点击下面的链接（实际上是我邀请链接，你们注册成功的话可以给我加每月5G的流量，嘿嘿）<br><a href="https://portal.qiniu.com/signup?code=3lito3c5lu2qa">https://portal.qiniu.com/signup?code=3lito3c5lu2qa</a></p>]]></content>
    
    
    <categories>
      
      <category>MISC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb 编码问题</title>
    <link href="/2016/12/20/JavaWeb%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2016/12/20/JavaWeb%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h2><ul><li><p>url中的编码。<br>分为两种情况：url路径和url参数（这里指的是手动在地址栏敲击中文等非ASCII字符）。采用何种字符集由浏览器决定。</p></li><li><p>form表单提交内容的编码。<br>不论是get还是post请求，采用的都是**“页面指定的编码”**。<br>指定页面编码有两种方式：</p></li></ul><ul><li>html中的meta标签: <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></li><li>返回本页面时服务端的返回头: <code>Content-Type:text/html;charset=gbk</code></li></ul><ul><li>ajax请求<br>实验证明ajax默认使用的是utf-8编码，和页面默认编码方式无关。<br>至少对于<strong>JQuery的ajax</strong>请求来说，在IE和Chrome上测试:</li></ul><ul><li>通过post请求提交的数据，服务端不做特殊处理也不会产生乱码；<br>   contentType: “application&#x2F;x-www-form-urlencoded; charset&#x3D;utf-8”  两种浏览器都会在加上这一请求头。</li><li>而对于get请求的话，两个浏览器的处理方式就不同了:<br>chrome中默认使用utf-8编码；而IE的编码方式未知</li></ul><ul><li>JS编码：</li></ul><ul><li>encodeURI两次编码，对应服务端的两次解码：tomcat解码一次加代码中解码一次。</li><li>+号消失问题：http协议遗留问题，服务端将+号当作空格的编码，解决办法：将加号用%2B替换或者使用encodeURIComponent解码部分内容</li><li>$.ajax的“data”参数，<code>data: param</code><br>如果param是js个对象，发送post请求的时候会以encodeURIComponent形式进行编码</li></ul><h2 id="HTTP服务器端（以Tomcat为例）"><a href="#HTTP服务器端（以Tomcat为例）" class="headerlink" title="HTTP服务器端（以Tomcat为例）##"></a>HTTP服务器端（以Tomcat为例）##</h2><p>浏览器向服务器提交请求内容，无非是使用get或者post两种方式（根据HTTP协议，还存在head，put等请求方式，这里先不讨论），所以服务端的解码方式自然也分两块，一是对于url中参数(queryString)的解码方式，二是对于请求体(postData)中内容的解码方式。</p><ul><li><p>Tomcat中对于requestBody中的内容(<strong>PostData</strong>)采用的默认编码为ISO-8859-1，<br>可在Servlet中设置：<code>request.setCharacterEncoding(&quot;utf-8&quot;);·</code><br>或者在提交时通过请求头指定编码类型：<code>Content-Type: application/x-www-form-urlencoded; charset=UTF-8</code><br>通过这两种方式让Tomcat以我们指定的字符集来解码。</p></li><li><p>对于URI中携带的参数，Tomcat会采用其默认编码字符集先对<strong>QueryString</strong>进行一次解码， Tomcat7及其之前的版本采用的编码集为ISO-8859-1 ，而到了Tomcat8I默认字符集改成了UTF-8。<br>可在tomcat的server.xml中配置，修改成自己想要的字符集。</p></li></ul><h3 id="JSP及Servlet-API的使用"><a href="#JSP及Servlet-API的使用" class="headerlink" title="JSP及Servlet API的使用"></a>JSP及Servlet API的使用</h3><ul><li><p>通常我们在JSP文件的Page指令标签中看到这样的声明：<br><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</code><br>指定了contentType属性，其效果是客户端如果请求这个jsp，服务器返回的响应报文会添加contentType这一响应头，通过这种方式可是指定当前页面的编码，这样浏览器既会以预期的编码来解析html，也会在提交form表单时使用这一字符集进行编码。</p></li><li><p>如何在Servlet里正确的设置ContentType</p><ul><li><p>服务端什么都不做<br>  结果：没有Content-Type这一个http响应头</p></li><li><p>response.setContentType(“text&#x2F;html”);  &#x2F;&#x2F; 没有指定charset<br>  结果：Content-Type:text&#x2F;html;charset&#x3D;ISO-8859-1，默认指定编码为IOS-8859-1，这样包含中文字符的话会出现乱码</p></li><li><p>response.setCharacterEncoding(“utf-8”);  &#x2F;&#x2F; 没有调用HttpServletResponse#setContentType方法<br>  结果：也没有Content-Type这一个http响应头</p></li><li><p>要想返回预期的Content-Type，如：”Content-Type:text&#x2F;html;charset&#x3D;UTF-8”, 有两种方式:</p></li></ul><ol><li></li></ol><p>  response.setContentType(“text&#x2F;html”);<br>  response.setCharacterEncoding(“utf-8”);<br>  2.<br>  response.setContentType(“text&#x2F;html;utf-8”);</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式和装饰器模式的区别</title>
    <link href="/2016/09/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2016/09/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>之前了解过“代理模式”，最经典的例子就是“房屋中介”，房东是<strong>被代理对象（也称为真实对象）</strong>，中介公司是<strong>代理对象</strong>，共同实现同一个接口，而租房子的家伙就是<strong>客户端调用者</strong>。租房狗调用一个租房接口，实现自己的租房业务，而中介公司作为租房接口的实现类，成为租房狗实际调用的对象（这就是面向接口编程的一种实践），租房狗是接触不到真正的房东的，但房子毕竟还是房东的啊，这意味着这核心的业务还是属于被代理对象的，代理对象只是在别人调用真实对象时，增加一些自己的方法，比如收点手续费什么的。这里就不上代码了，网上有很多相关的例子讲的很清楚。</p><p>作为java程序员，最经典的关于的代理例子，当然是Spring的AOP啦！Spring AOP为真实对象注入切面，包括日志、权限检验，方法拦截等。</p><p>之前对“装饰器模式”的理解很模糊，知道java的IO框架大量地用到这个模式，今天上午看了几篇讲“装饰器模式”的文章，发现：咦？<strong>装饰器</strong>和<strong>被装饰对象</strong>怎么也是实现同一个接口？怎么也是在增强被装饰对象的真实方法？突然有点糊涂了。</p><p>随即在网上搜了几篇讲两者区别的文章，归纳起来大致是这样的：</p><ol><li>使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而对于装饰器模式，被装饰对象的引用通常是作为装饰器的构造函数的参数传入的，这种关系在运行期才能确定。<br><code>这个说法还真的有待商榷，那怎么解释Spring AOP运行期的动态代理机制呢，就算抛开这个不谈，我觉得这并不是两者的核心区别</code></li><li>代理模式是控制<strong>控制访问</strong>，而装饰器模式是<strong>新增行为</strong>。<br><code>相比较而言，这个说法还是比较靠谱的，可问题又来了，如何区分“控制访问”和“新增行为呢”，这个问题确实不好回答，AOP里的方法拦截算不算一种“新增行为”呢？某些时候单从字面去理解的话，确实不太好判定</code></li></ol><p>其实我对这两个模式的理解也不是很深刻，例如“装饰器模式”里提高，它是使用“组合”来代替“继承”以拓展父类的方法，对于“组合”和“继承”的区别优劣还不是特别理解。<br>总而言之，要想理解某个设计模式单靠看概念肯定是不够的，还必须结合自己的编程实际以及源码阅读还提升自己的理解能力。<br>这篇文章也只是记录我对这两个模式的一点思考，自然是不够系统全面的，先在这里立一个flag，等以后知识水平提高了再来谈笑风生，全面地介绍关于设计模式的人生经验。</p><p>参考链接：<br><a href="http://blog.csdn.net/ljl157011/article/details/17882253">http://blog.csdn.net/ljl157011/article/details/17882253</a><br><a href="http://www.iteye.com/topic/830861">http://www.iteye.com/topic/830861</a></p>]]></content>
    
    
    <categories>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 枚举类初探: 反编译&amp;语法糖</title>
    <link href="/2016/09/04/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%88%9D%E6%8E%A2-%E5%8F%8D%E7%BC%96%E8%AF%91-%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2016/09/04/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%88%9D%E6%8E%A2-%E5%8F%8D%E7%BC%96%E8%AF%91-%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<p>最近接触了“<strong>语法糖”<strong>这个概念，今天又看了一下</strong>枚举类</strong>的知识点，主要还是看它的用法，之前一直没有怎么用过java枚举类，看了李刚那本《疯狂java讲义》的枚举类章节，算是把它的用法弄明白了。</p><p>可是枚举类是一种“语法糖”，也就是说<strong>只有编译器知道“enum”关键字，jvm是不知道的，字节码文件中没有枚举这一概念</strong>。实际上，书中一开头就提到了在枚举出现前，程序员需要自己编程实现枚举（具体就不展开了），比较复杂，JDK1.5之后出现了enum枚举类（可以看做是一种特殊的java类）——作为一种“语法糖”让程序员更方便地实现枚举，对程序员更加友好、“甜蜜”了，哈哈。</p><p>我对java语法糖的理解是这样的：可以看做编译器先把原来的enum类编译成“正常的java类”，然后再以正常的方式编译成字节码，所以字节码当然不知道有“语法糖”的存在啦，不知道我的理解有没有错，应该是没有什么大问题，如果有的话还请各位大神指正。<br>为了更好的理解枚举类是怎么实现的，我先是按照书中对枚举类的定义写了一个对应于enum类的“正常的java类”，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.Enum;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">public enum TrueEnum &#123;</span><br><span class="hljs-comment">WHITE, BLACK;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEnum</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span> &#123; <span class="hljs-comment">// 这样写肯定是通不过编译的，因为编译器不允许我们的类显示的继承Enum类</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">MyEnum</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MyEnum</span> <span class="hljs-variable">e1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEnum</span>(<span class="hljs-string">&quot;WHITE&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MyEnum</span> <span class="hljs-variable">e2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEnum</span>(<span class="hljs-string">&quot;BLACK&quot;</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">public</span> MyEnum[] values() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEnum</span>[]&#123;e1, e2&#125;; <span class="hljs-comment">// 这个地方有问题，等下指出</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后来想反编译一下TrueEum.class(这个是enum类），和自己写的代码对比一下看对不对，就下了一个反编译程序jd-gui，没想到这个程序太高级了，直接反编译成enum类了（囧），又不知道怎么弄成“低级”的，就直接上网搜了别人的博客，看他们贴出的反编译代码，发现自己的猜想还是基本正确的，除了values()方法，正确的实现应该是返回数组的一个浅拷贝（return array.clone()），而不是像我这样简单的返回一个数组引用，后来想想：如果调用者搞破坏怎么办？比如通过数据引用把某个数据元素换成其他值不就破坏了原对象的封装性了吗。看来自己还是too young。</p><p>看了两三篇博客，这篇写的不错：<a href="http://blog.jrwang.me/2016/java-enum/">Java 枚举源码分析</a>主要是排版看起来比较舒服，分析的也比较全面。</p><p>不过还有一点值得注意的是，这篇文章没有指出enum类实现接口和添加抽象方法这两种情况，这样的话，枚举值就不是作为枚举类的实例了，而是作为枚举类的匿名子类的实现类。<br>也就是说枚举值要么是Enum的直接子类要么是Enum的“孙子类”（这个词是我发明的，理解意思就好，蛤蛤），知道这点的话，下面这段Enum的源码就很好理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 得到枚举常量所属枚举类型的Class对象  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Class&lt;E&gt; <span class="hljs-title function_">getDeclaringClass</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> getClass();  <br>    <span class="hljs-type">Class</span> <span class="hljs-variable">zuper</span> <span class="hljs-operator">=</span> clazz.getSuperclass();  <br>    <span class="hljs-keyword">return</span> (zuper == Enum.class) ? clazz : zuper;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这是我基于刚才提到的那篇博客做的一点补充，做了一点微薄的贡献，谢谢大家。<br>第一次发表博客，就先这样吧，献丑了，欢迎各位朋友批评指正。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
